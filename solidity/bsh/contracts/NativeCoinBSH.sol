pragma solidity >=0.5.0 <=0.8.0;
pragma experimental ABIEncoderV2;
import "./Interfaces/IBSH.sol";
import "./Interfaces/IBMC.sol";
import "./Libraries/TypesLib.sol";
import "./Libraries/RLPEncodeStructLib.sol";
import "./Libraries/RLPDecodeStructLib.sol";
import "./Libraries/ParseAddressLib.sol";
import "./Libraries/StringsLib.sol";
import "./Libraries/Owner.sol";
import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";

/**
   @title Interface of BSH Coin transfer service
   @dev This contract use to handle coin transfer service
   Note: The coin of following interface can be:
   Native Coin : The native coin of this chain
   Wrapped Native Coin : A tokenized ERC1155 version of another native coin like ICX
*/
contract NativeCoinBSH is IBSH, ERC1155, ERC1155Holder, Owner {
    using RLPEncodeStruct for Types.TransferCoin;
    using RLPEncodeStruct for Types.ServiceMessage;
    using RLPEncodeStruct for Types.Response;
    using RLPDecodeStruct for bytes;
    using SafeMath for uint256;
    using ParseAddress for address;
    using ParseAddress for string;
    using Address for address;
    using Strings for string;

    /**   @notice Sends a receipt to user
        The `_to` receiver.
        The `_sn` sequence number of service message.
        The `_coinName` the name of coin.
        The `_value` transfer value.    
    */
    event TransferStart(
        address indexed _from,
        string _to,
        uint256 _sn,
        string _coinName,
        uint256 _value
    );

    event TransferEnd(
        address indexed _from,
        uint256 _sn,
        uint256 _code,
        string _response
    );
    IBMC private bmc;
    mapping(uint256 => Types.Record) public requests; // a list of transferring requests
    mapping(address => mapping(string => Types.Balance)) private balances;
    mapping(string => Types.Coin) private coins; //  a list of all supported coins
    string[] private coinsName; // a string array stores names of supported coins
    uint256 private numOfCoins;
    string public serviceName; //    BSH Service Name

    uint256 private constant RC_OK = 0;
    uint256 private constant RC_ERR = 1;

    uint256 private serialNo; //  a counter of request service, i.e. Transfer Coin/Token

    modifier onlyBMC {
        require(msg.sender == address(bmc), "Only BMC");
        _;
    }

    constructor(
        address _bmc,
        string memory _serviceName,
        string memory _nativeCoinName,
        string memory _symbol,
        uint256 _decimals
    ) ERC1155("") Owner() {
        bmc = IBMC(_bmc);
        serviceName = _serviceName;
        coins[_nativeCoinName] = Types.Coin(
            0, //  native coin is assigend '_id' = 0
            _symbol,
            _decimals
        );
        coinsName.push(_nativeCoinName);
        numOfCoins++;
        serialNo = 0;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override(ERC1155Receiver, ERC1155)
        returns (bool)
    {
        return
            ERC1155Receiver.supportsInterface(interfaceId) ||
            ERC1155.supportsInterface(interfaceId);
    }

    /***********************************************************************************
                    Coin/Wrapped Native Coin Related Functions

        - Functions to register wrapped native coins from another blockchains
        - Functions to query supported Coins/Wrapped Coins  
        - Functions to query Spendable and Locked Balance of Coins/Wrapped Coins                   
    ************************************************************************************/

    /**
     @notice Registers a wrapped coin and id number of a supporting coin.
     @dev Caller must be an operator of BTP network
     _name Must be different with the native coin name.
     @dev '_id' of a wrapped coin is generated by using keccak256
     '_id' = 0 is fixed to assign to native coin
     @param _name    Coin name.
     @param _symbol    Coin symbol.     
     @param _decimals    decimals number.    
    */
    function register(
        string calldata _name,
        string calldata _symbol,
        uint256 _decimals
    ) external owner {
        require(bytes(coins[_name].symbol).length == 0, "Token existed");
        coins[_name] = Types.Coin(
            uint256(keccak256(abi.encodePacked(_name))),
            _symbol,
            _decimals
        );
        coinsName.push(_name);
        numOfCoins++;
    }

    /**
       @notice Remove a wrapped native coin. 
       @dev Caller must be an operator of BTP network.
       @param _name    Name of a token to be removed.
   */
    // function unregister(string calldata _name) external owner {
    //     require(bytes(coins[_name].symbol).length != 0, "Token not existed");
    //     delete coins[_name];
    //     numOfCoins--;
    // }

    /**
       @notice Return all supported coins names in other networks by the BSH contract
       @dev 
       @return _names   An array of strings.
    */
    function coinNames() external view returns (string[] memory _names) {
        _names = new string[](numOfCoins);
        uint256 temp = 0;
        for (uint256 i = 0; i < coinsName.length; i++) {
            if (bytes(coins[coinsName[i]].symbol).length != 0) {
                _names[temp] = coinsName[i];
                temp++;
            }
        }
        return _names;
    }

    /**
       @notice  Return an _id number and a symbol of Coin whose name is the same with given _coinName.
       @dev     Return nullempty if not found.
       @return  A Coin object.
    */
    function coinOf(string calldata _coinName)
        external
        view
        returns (Types.Coin memory)
    {
        return coins[_coinName];
    }

    /*
     @notice Return a usable/locked balance of an account based on coinName.
     @dev    Locked Balance means an amount of Coins/Wrapped Coins is currently 
             at a pending state when a transfer tx is requested from this chain to another
     @dev    Return 0 if not found
     @return _lockedBalance = an amount of locked Coins/WrappedCoins
     @return _usableBalance = an amount of spendable Coins/WrappedCoins 
     @return _refundableBalance = an amount of Coins on waiting to re-claim
    */
    function getBalanceOf(address _owner, string memory _coinName)
        external
        view
        returns (
            uint256 _usableBalance,
            uint256 _lockedBalance,
            uint256 _refundableBalance
        )
    {
        //  Check whether _coinName is a nativeCoin
        if (
            coins[_coinName].id == 0 &&
            bytes(coins[_coinName].symbol).length != 0
        ) {
            return (
                _owner.balance,
                balances[_owner][_coinName].lockedBalance,
                balances[_owner][_coinName].refundableBalance
            );
        }

        return (
            this.balanceOf(_owner, coins[_coinName].id),
            balances[_owner][_coinName].lockedBalance,
            balances[_owner][_coinName].refundableBalance
        );
    }

    /*
     @notice Return an amount of Coins on waiting to re-claim
     @dev    Refundable Balance is an amount of native coin that was failed to refund
             in handleBTPMessage with error/handleBTPError
             In the case, receiving contract does not implement 
             receive() external payable or fallback() external payable.
             It prones to fail on transfer. Thus, refundable balance comes up
     @dev    Return 0 if not found
    */
    // function getRefundableBalance(address _owner, string memory _coinName)
    //     external
    //     view
    //     returns (uint256)
    // {
    //     return balances[_owner][_coinName].refundableBalance;
    // }

    /*
     @notice Return a list locked/usable balance of an account.
     @dev The order of request's coinNames must be the same with the order of return balance
     @dev Return 0 if not found.
     @return _usableBalances[] An array of spendable balances 
     @return _lockedBalances[] An array of locked balances
    */
    function getBalanceOfBatch(address _owner, string[] calldata _coinNames)
        external
        view
        returns (
            uint256[] memory _usableBalances,
            uint256[] memory _lockedBalances,
            uint256[] memory _refundableBalances
        )
    {
        _usableBalances = new uint256[](_coinNames.length);
        _lockedBalances = new uint256[](_coinNames.length);
        _refundableBalances = new uint256[](_coinNames.length);
        for (uint256 i = 0; i < _coinNames.length; i++) {
            (
                _usableBalances[i],
                _lockedBalances[i],
                _refundableBalances[i]
            ) = this.getBalanceOf(_owner, _coinNames[i]);
        }
        return (_usableBalances, _lockedBalances, _refundableBalances);
    }

    /**
       @notice Reclaim the coin's refundable balance by an owner.
       @dev Caller must be an owner of coin
       @dev This function only applies on native coin (not wrapped coins)
       The amount to claim must be smaller than refundable balance
       @param _coinName   A given name of coin to be re-claim
       @param _value       An amount of re-claiming 
    */
    function reclaim(string calldata _coinName, uint256 _value) external {
        require(
            bytes(coins[_coinName].symbol).length != 0,
            "Token not supported"
        );
        require(
            balances[msg.sender][_coinName].refundableBalance >= _value,
            "Insufficient balance"
        );

        balances[msg.sender][_coinName].refundableBalance = balances[
            msg.sender
        ][_coinName]
            .refundableBalance
            .sub(_value);

        if (_coinName.compareTo(coinsName[0])) {
            payable(msg.sender).transfer(_value);
        } else {
            this.safeTransferFrom(
                address(this),
                msg.sender,
                coins[_coinName].id,
                _value,
                ""
            );
        }
    }

    /***********************************************************************************
                    Coins/Wrapped Coins Transfer Related Functions

        - Function handles request transfer Coins to another chain
        - Function handles request transfer Wrapped Coins to another chain  
        - Prepare Service Message and send it to a BMC contract                   
    ************************************************************************************/

    /**
       @notice Allow users to deposit `msg.value` native coin into a BSH contract.
       @dev MUST specify msg.value
       @param _to  An address that a user expects to receive an equivalent amount of tokens.
    */
    function transfer(string calldata _to) external payable {
        require(msg.value > 0, "Invalid amount");
        sendServiceMessage(_to, coinsName[0], msg.value);
    }

    /**
       @notice Allow users to deposit an amount of wrapped native coin `_coinName` from the `msg.sender` address into the BSH contract.
       @dev Caller must set to approve that the wrapped tokens can be transferred out of the `msg.sender` account by the operator.
       It MUST revert if the balance of the holder for token `_coinName` is lower than the `_value` sent.
       @param _coinName    A given name of coin that is equivalent to retrieve a wrapped Token Contract's address, i.e. list["Token A"] = 0x12345678
       @param _value       Transferring amount.
       @param _to          Target address.
    */
    function transfer(
        string calldata _coinName,
        uint256 _value,
        string calldata _to
    ) external {
        require(_value > 0, "Invalid amount");
        require(
            bytes(coins[_coinName].symbol).length != 0,
            "Token not supported"
        );
        //  Transfer and Lock Token processes:
        //  To transfer, BSH contract call safeTransferFrom()  to transfer
        //  the Token from Caller's account (msg.sender)
        //  For such thing, Caller must approve (setApproveForAll) to accept
        //  token being transfer out by an Operator
        //  If it is failed, this transaction is reverted.
        //  After transferring token, BSH contract set Caller's locked balance
        //  as a record of pending transfer tx
        //  When a tx is completed without error on another chain,
        //  Locked Token amount (bind to address of caller) will be reset/subtract
        //  If not, this locked amount will be updated (subtract or set to 0)
        //  and BSH contract will issue a Token refund to Caller
        uint256 _id = coins[_coinName].id;
        this.safeTransferFrom(msg.sender, address(this), _id, _value, "");
        sendServiceMessage(_to, _coinName, _value);
    }

    function sendServiceMessage(
        string calldata _to,
        string memory _coinName,
        uint256 _value
    ) private {
        balances[msg.sender][_coinName].lockedBalance = _value.add(
            balances[msg.sender][_coinName].lockedBalance
        );

        //  Send Service Message to BMC
        //  If _to address is an invalid BTP Address format
        //  VM throws an error and revert(). Thus, it does not need
        //  a try_catch at this point
        string memory _toNetwork;
        string memory _toAddress;
        (_toNetwork, _toAddress) = _to.splitBTPAddress();

        bmc.sendMessage(
            _toNetwork,
            serviceName,
            serialNo,
            Types
                .ServiceMessage(
                Types
                    .ServiceType
                    .REQUEST_COIN_TRANSFER,
                Types
                    .TransferCoin(
                    address(msg.sender).toString(),
                    _toAddress,
                    _coinName,
                    _value
                )
                    .encodeData()
            )
                .encodeServiceMessage()
        );

        //  Push pending tx into Record list
        requests[serialNo] = Types.Record(
            Types.TransferCoin(
                address(msg.sender).toString(),
                _to,
                _coinName,
                _value
            ),
            Types.Response(0, ""),
            false
        );

        emit TransferStart(msg.sender, _to, serialNo, _coinName, _value);
        serialNo++;
    }

    /***********************************************************************************
                                BTP Message Handler Functions                  
    ************************************************************************************/

    function handleBTPMessage(
        string calldata _from,
        string calldata _svc,
        uint256 _sn,
        bytes calldata _msg
    ) external override onlyBMC {
        Types.ServiceMessage memory _sm = _msg.decodeServiceMessage();
        if (_sm.serviceType == Types.ServiceType.REQUEST_COIN_TRANSFER) {
            Types.TransferCoin memory _tc = _sm.data.decodeData();
            handleRequestService(_tc.coinName, _tc.to, _from, _tc.value, _sn);
            return;
        } else if (
            _sm.serviceType == Types.ServiceType.REPONSE_HANDLE_SERVICE
        ) {
            Types.Response memory response = _sm.data.decodeResponse();
            address caller = requests[_sn].request.from.parseAddress();
            string memory _coinName = requests[_sn].request.coinName;
            uint256 value = requests[_sn].request.value;
            if (response.code == 1) {
                handleErrorResponse(_sn, response.code, response.message);
            } else {
                //  When a transfer tx is completed, locked balance amount should be update
                //  and also BSH contract's tokens will be burn
                balances[msg.sender][_coinName].lockedBalance = balances[
                    msg.sender
                ][_coinName]
                    .lockedBalance
                    .sub(value);
                _burn(address(this), coins[_coinName].id, value);
            }
            emit TransferEnd(caller, _sn, response.code, response.message);
            return;
        } else if (_sm.serviceType == Types.ServiceType.UNKNOWN_TYPE) {
            //  If receiving a RES_UNKNOWN_TYPE, ignore this message
            //  or re-send another correct message
            return;
        }
        //  If none of those types above, BSH responds a message of RES_UNKNOWN_TYPE
        sendResponseMessage(
            Types.ServiceType.UNKNOWN_TYPE,
            _from,
            _sn,
            "UNKNOWN_TYPE",
            RC_ERR
        );
    }

    function handleBTPError(
        string memory _src,
        string memory _svc,
        uint256 _sn,
        uint256 _code,
        string memory _msg
    ) external override onlyBMC {
        handleErrorResponse(_sn, _code, _msg);
    }

    function handleErrorResponse(
        uint256 _sn,
        uint256 _code,
        string memory _msg
    ) private {
        //  When receiving BTPError, refund Coins/Wrapped Coins back to a Caller
        //  Updating locked balance of a Caller

        address caller = requests[_sn].request.from.parseAddress();
        string memory _coinName = requests[_sn].request.coinName;
        uint256 value = requests[_sn].request.value;

        if (
            coins[_coinName].id == 0 &&
            bytes(coins[_coinName].symbol).length != 0
        ) {
            (bool success, ) = caller.call{gas: 2300, value: value}("");
            if (!success) {
                balances[caller][_coinName].refundableBalance = balances[
                    caller
                ][_coinName]
                    .refundableBalance
                    .add(value);
            }
        } else {
            uint256 _id = coins[_coinName].id;
            try this.tryToTransferToken(caller, _id, value) {} catch Error(
                string memory
            ) {
                balances[caller][_coinName].refundableBalance = balances[
                    caller
                ][_coinName]
                    .refundableBalance
                    .add(value);
            } catch (bytes memory) {
                balances[caller][_coinName].refundableBalance = balances[
                    caller
                ][_coinName]
                    .refundableBalance
                    .add(value);
            }
        }

        balances[msg.sender][_coinName].lockedBalance = balances[msg.sender][
            _coinName
        ]
            .lockedBalance
            .sub(value);

        //  Finally, updating Record from Pending state -> Resolved
        requests[_sn] = Types.Record(
            requests[_sn].request,
            Types.Response(_code, _msg),
            true
        );
    }

    function handleRequestService(
        string memory _coinName,
        string memory _toAddress,
        string calldata _toNetwork,
        uint256 _amount,
        uint256 _sn
    ) private {
        //  If a receiving address is a invalid format address
        //  return BSH replies RC_ERR Response
        try this.checkParseAddress(_toAddress) {} catch Error(
            string memory err
        ) {
            sendResponseMessage(
                Types.ServiceType.REPONSE_HANDLE_SERVICE,
                _toNetwork,
                _sn,
                err,
                RC_ERR
            );
            return;
        } catch (bytes memory) {
            sendResponseMessage(
                Types.ServiceType.REPONSE_HANDLE_SERVICE,
                _toNetwork,
                _sn,
                "Invalid format address",
                RC_ERR
            );
            return;
        }
        //  Compare _coinName with supporting native coin
        //  If so, refund a native coin
        if (
            coins[_coinName].id == 0 &&
            bytes(coins[_coinName].symbol).length != 0
        ) {
            (bool success, ) =
                _toAddress.parseAddress().call{gas: 2300, value: _amount}("");
            if (success) {
                sendResponseMessage(
                    Types.ServiceType.REPONSE_HANDLE_SERVICE,
                    _toNetwork,
                    _sn,
                    "Transfer Success",
                    RC_OK
                );
            } else {
                sendResponseMessage(
                    Types.ServiceType.REPONSE_HANDLE_SERVICE,
                    _toNetwork,
                    _sn,
                    "Unable send to address of receiver",
                    RC_ERR
                );
            }
        }
        uint256 _id = coins[_coinName].id;
        if (_id == 0) {
            sendResponseMessage(
                Types.ServiceType.REPONSE_HANDLE_SERVICE,
                _toNetwork,
                _sn,
                "Invalid Token",
                RC_ERR
            );
            return;
        }
        //  @dev Receiving address should be ERC1155Holder
        //  Using try_catch method to mint Tokens to a receiving address
        //  If there's no error, BSH replies RC_OK Response
        //  Otherwise, BSH replies RC_ERR with an error message
        try this.tryToMintToken(_toAddress.parseAddress(), _id, _amount) {
            sendResponseMessage(
                Types.ServiceType.REPONSE_HANDLE_SERVICE,
                _toNetwork,
                _sn,
                "Transfer Success",
                RC_OK
            );
        } catch Error(string memory err) {
            sendResponseMessage(
                Types.ServiceType.REPONSE_HANDLE_SERVICE,
                _toNetwork,
                _sn,
                err,
                RC_ERR
            );
        } catch (bytes memory) {
            sendResponseMessage(
                Types.ServiceType.REPONSE_HANDLE_SERVICE,
                _toNetwork,
                _sn,
                "Transfer failed",
                RC_ERR
            );
        }
    }

    function sendResponseMessage(
        Types.ServiceType _serviceType,
        string memory _to,
        uint256 _sn,
        string memory _msg,
        uint256 _code
    ) private {
        bmc.sendMessage(
            _to,
            serviceName,
            _sn,
            Types
                .ServiceMessage(
                _serviceType,
                Types.Response(_code, _msg).encodeResponse()
            )
                .encodeServiceMessage()
        );
    }

    //  @dev Solidity does not allow using try_catch with internal function
    //  To do such thing, it has to be done this way
    //  If there is any error thrown when parsing a string address, i.e. invalid format
    //  an error can be caught, then BSH can reply back a RC_ERR Response
    //  instead of throwing VM Error with a revert
    function checkParseAddress(string calldata _to) external {
        _to.parseAddress();
    }

    //  @dev Despite this function was set as external, it should be called internally
    //  since Solidity does not allow using try_catch with internal function
    //  this solution can solve the issue
    function tryToTransferToken(
        address _to,
        uint256 _id,
        uint256 _amount
    ) external {
        require(msg.sender == address(this), "Only BSH");
        this.safeTransferFrom(address(this), _to, _id, _amount, "");
    }

    //  @dev Despite this function was set as external, it should be called internally
    //  since Solidity does not allow using try_catch with internal function
    //  this solution can solve the issue
    function tryToMintToken(
        address _to,
        uint256 _id,
        uint256 _amount
    ) external {
        require(msg.sender == address(this), "Only BSH");
        _mint(_to, _id, _amount, "");
    }
}
