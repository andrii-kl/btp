// SPDX-License-Identifier: MIT
pragma solidity >=0.5.0 <0.8.0;
pragma experimental ABIEncoderV2;

import "./StringsLib.sol";
import "./IBSHPeriphery.sol";
import "@openzeppelin/contracts-upgradeable/math/SafeMathUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/ERC1155HolderUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
/**
   @title Interface of BSH Coin transfer service
   @dev This contract use to handle coin transfer service
   Note: The coin of following interface can be:
   Native Coin : The native coin of this chain
   Wrapped Native Coin : A tokenized ERC1155 version of another native coin like ICX
*/
contract BSHCoreV2 is Initializable, ERC1155Upgradeable, ERC1155HolderUpgradeable, OwnableUpgradeable {
    using Strings for string;
    struct Balance {
        uint256 lockedBalance;
        uint256 refundableBalance;
    }
    
    mapping(address => mapping(string => Balance)) private balances;
    mapping(string => uint256) private coins; //  a list of all supported coins
    string[] private coinsName; // a string array stores names of supported coins
    //  Add more state variables at the end of previous ones
    IBSHPeriphery private bshPeriphery;
    uint256 private constant FEE_DENOMINATOR = 10**4;
    uint256 private feeNumerator;

    function initialize (
        string calldata _uri,
        string calldata _nativeCoinName
    ) public initializer {
        __ERC1155_init(_uri);
         __ERC1155Holder_init();
        __Ownable_init();

        coins[_nativeCoinName] = 0;         
        coinsName.push(_nativeCoinName);
    }

    /**
        @notice update bsh service address.
        @dev Caller must be an operator of BTP network
        _bshPeriphery Must be different with the existing one.
        @param _bshPeriphery    bsh service address.
    */
    function updateBSHPeriphery(address _bshPeriphery) external onlyOwner {
        bshPeriphery = IBSHPeriphery(_bshPeriphery);
    }
    
    /**
        @notice update base uri.
        @dev Caller must be an operator of BTP network
        the uri must be initilized in construction.
        @param _newURI    new uri
    */
    function updateUri(string calldata _newURI) external onlyOwner {
       _setURI(_newURI);
    }

    /**
        @notice set fee ratio.
        @dev Caller must be an operator of BTP network
        The transfer fee is calculated by feeNumerator/FEE_DEMONINATOR. 
        The feeNumetator should be less than FEE_DEMONINATOR and greater than 1
        _feeNumerator is set to `10` in construction by default, which means the default fee ratio is 0.1%.
        @param _feeNumerator    the fee numerator
    */
    function setFeeRatio(uint256 _feeNumerator) external onlyOwner {
        feeNumerator = _feeNumerator;
    }

    /**
        @notice Registers a wrapped coin and id number of a supporting coin.
        @dev Caller must be an Contract Owner
        _name Must be different with the native coin name.
        @dev '_id' of a wrapped coin is generated by using keccak256
          '_id' = 0 is fixed to assign to native coin
        @param _name    Coin name. 
    */
    function register(
        string calldata _name
    ) external onlyOwner {
        require(coins[_name] == 0, "ExistToken");
        coins[_name] = uint256(keccak256(abi.encodePacked(_name)));
        coinsName.push(_name);
    }

    /**
       @notice Return all supported coins names in other networks by the BSH contract
       @dev 
       @return _names   An array of strings.
    */
    function coinNames() external view returns (string[] memory _names) {
        return coinsName;
    }

    /**
       @notice  Return an _id number of Coin whose name is the same with given _coinName.
       @dev     Return nullempty if not found.
       @return  _coinId     An ID number of _coinName.
    */
    function coinId(string calldata _coinName) external view returns (uint256 _coinId) {
        return coins[_coinName];
    }

    /**
       @notice  Check Validity of a _coinName
       @dev     Call by BSHPeriphery contract to validate a requested _coinName
       @return  _valid     true of false
    */
    function isValidCoin(string calldata _coinName) external view returns (bool _valid) {
        if (coins[_coinName] != 0 || _coinName.compareTo(coinsName[0])) {
            return true;
        }
        return false;
    }

    /**
        @notice Return a usable/locked/refundable balance of an account based on coinName.
        @return _usableBalance the balance that users are holding.
        @return _lockedBalance when users transfer the coin, 
                it will be locked until getting the Service Message Response.
        @return _refundableBalance refundable balance is the balance that will be refunded to users.
    */

    function getBalanceOf(address _owner, string memory _coinName)
        external
        view
        returns (uint256 _usableBalance, uint256 _lockedBalance, uint256 _refundableBalance)
    {
        if (_coinName.compareTo(coinsName[0])) {
            return (
                address(_owner).balance,
                balances[_owner][_coinName].lockedBalance,
                balances[_owner][_coinName].refundableBalance
            );
        }
        return (
            this.balanceOf(_owner, coins[_coinName]),
            balances[_owner][_coinName].lockedBalance,
            balances[_owner][_coinName].refundableBalance
        );
    }

    /**
        @notice Return a list Balance of an account.
        @dev The order of request's coinNames must be the same with the order of return balance
        Return 0 if not found.
        @return _usableBalances         An array of Usable Balances
        @return _lockedBalances         An array of Locked Balances
        @return _refundableBalances     An array of Refundable Balances
    */

    function getBalanceOfBatch(address _owner, string[] calldata _coinNames)
        external
        view
        returns
    (
        uint256[] memory _usableBalances,
        uint256[] memory _lockedBalances,
        uint256[] memory _refundableBalances
    ){
        _usableBalances = new uint256[](_coinNames.length);
        _lockedBalances = new uint256[](_coinNames.length);
        _refundableBalances = new uint256[](_coinNames.length);
        for (uint256 i = 0; i < _coinNames.length; i++) {
            (_usableBalances[i], _lockedBalances[i], _refundableBalances[i]) =
                this.getBalanceOf(_owner, _coinNames[i]);
        }
        return (_usableBalances, _lockedBalances, _refundableBalances);
    }
}
