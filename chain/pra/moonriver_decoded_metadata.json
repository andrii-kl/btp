{
  "MagicNumber": 1635018093,
  "Version": 13,
  "IsMetadataV4": false,
  "AsMetadataV4": {
    "Modules": null
  },
  "IsMetadataV7": false,
  "AsMetadataV7": {
    "Modules": null
  },
  "IsMetadataV8": false,
  "AsMetadataV8": {
    "Modules": null
  },
  "IsMetadataV9": false,
  "AsMetadataV9": {
    "Modules": null
  },
  "IsMetadataV10": false,
  "AsMetadataV10": {
    "Modules": null
  },
  "IsMetadataV11": false,
  "AsMetadataV11": {
    "Modules": null,
    "Extrinsic": {
      "Version": 0,
      "SignedExtensions": null
    }
  },
  "IsMetadataV12": false,
  "AsMetadataV12": {
    "Modules": null,
    "Extrinsic": {
      "Version": 0,
      "SignedExtensions": null
    }
  },
  "IsMetadataV13": true,
  "AsMetadataV13": {
    "Modules": [
      {
        "Name": "System",
        "HasStorage": true,
        "Storage": {
          "Prefix": "System",
          "Items": [
            {
              "Name": "Account",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "AccountInfo\u003cT::Index, T::AccountData\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
              "Documentation": [
                " The full account information for a particular account ID."
              ]
            },
            {
              "Name": "ExtrinsicCount",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u32",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Total extrinsics count for the current block."
              ]
            },
            {
              "Name": "BlockWeight",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "ConsumedWeight",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
              "Documentation": [
                " The current weight for the block."
              ]
            },
            {
              "Name": "AllExtrinsicsLen",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u32",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Total length (in bytes) for all extrinsics put together, for the current block."
              ]
            },
            {
              "Name": "BlockHash",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::BlockNumber",
                  "Value": "T::Hash",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
              "Documentation": [
                " Map of block numbers to block hashes."
              ]
            },
            {
              "Name": "ExtrinsicData",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "u32",
                  "Value": "Vec\u003cu8\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Extrinsics data for the current block (maps an extrinsic's index to its data)."
              ]
            },
            {
              "Name": "Number",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::BlockNumber",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " The current block number being processed. Set by `execute_block`."
              ]
            },
            {
              "Name": "ParentHash",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::Hash",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
              "Documentation": [
                " Hash of the previous block."
              ]
            },
            {
              "Name": "Digest",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "DigestOf\u003cT\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Digest of the current block, also part of the block header."
              ]
            },
            {
              "Name": "Events",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cEventRecord\u003cT::Event, T::Hash\u003e\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Events deposited for the current block."
              ]
            },
            {
              "Name": "EventCount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "EventIndex",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " The number of events in the `Events\u003cT\u003e` list."
              ]
            },
            {
              "Name": "EventTopics",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "T::Hash",
                  "Value": "Vec\u003c(T::BlockNumber, EventIndex)\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Mapping between a topic (represented by T::Hash) and a vector of indexes",
                " of events in the `\u003cEvents\u003cT\u003e\u003e` list.",
                "",
                " All topic vectors have deterministic storage locations depending on the topic. This",
                " allows light-clients to leverage the changes trie storage tracking mechanism and",
                " in case of changes fetch the list of events of interest.",
                "",
                " The value has the type `(T::BlockNumber, EventIndex)` because if we used only just",
                " the `EventIndex` then in case if the topic has the same contents on the next block",
                " no notification will be triggered thus the event might be lost."
              ]
            },
            {
              "Name": "LastRuntimeUpgrade",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "LastRuntimeUpgradeInfo",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened."
              ]
            },
            {
              "Name": "UpgradedToU32RefCount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "bool",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " True if we have upgraded so that `type RefCount` is `u32`. False (default) if not."
              ]
            },
            {
              "Name": "UpgradedToTripleRefCount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "bool",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " True if we have upgraded so that AccountInfo contains three types of `RefCount`. False",
                " (default) if not."
              ]
            },
            {
              "Name": "ExecutionPhase",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Phase",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The execution phase of the block."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "fill_block",
            "Args": [
              {
                "Name": "_ratio",
                "Type": "Perbill"
              }
            ],
            "Documentation": [
              " A dispatch that will fill the block weight up to the given ratio."
            ]
          },
          {
            "Name": "remark",
            "Args": [
              {
                "Name": "_remark",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Make some on-chain remark.",
              "",
              " # \u003cweight\u003e",
              " - `O(1)`",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "set_heap_pages",
            "Args": [
              {
                "Name": "pages",
                "Type": "u64"
              }
            ],
            "Documentation": [
              " Set the number of pages in the WebAssembly environment's heap.",
              "",
              " # \u003cweight\u003e",
              " - `O(1)`",
              " - 1 storage write.",
              " - Base Weight: 1.405 µs",
              " - 1 write to HEAP_PAGES",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "set_code",
            "Args": [
              {
                "Name": "code",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Set the new runtime code.",
              "",
              " # \u003cweight\u003e",
              " - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`",
              " - 1 storage write (codec `O(C)`).",
              " - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).",
              " - 1 event.",
              " The weight of this function is dependent on the runtime, but generally this is very expensive.",
              " We will treat this as a full block.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "set_code_without_checks",
            "Args": [
              {
                "Name": "code",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Set the new runtime code without doing any checks of the given `code`.",
              "",
              " # \u003cweight\u003e",
              " - `O(C)` where `C` length of `code`",
              " - 1 storage write (codec `O(C)`).",
              " - 1 event.",
              " The weight of this function is dependent on the runtime. We will treat this as a full block.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "set_changes_trie_config",
            "Args": [
              {
                "Name": "changes_trie_config",
                "Type": "Option\u003cChangesTrieConfiguration\u003e"
              }
            ],
            "Documentation": [
              " Set the new changes trie configuration.",
              "",
              " # \u003cweight\u003e",
              " - `O(1)`",
              " - 1 storage write or delete (codec `O(1)`).",
              " - 1 call to `deposit_log`: Uses `append` API, so O(1)",
              " - Base Weight: 7.218 µs",
              " - DB Weight:",
              "     - Writes: Changes Trie, System Digest",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "set_storage",
            "Args": [
              {
                "Name": "items",
                "Type": "Vec\u003cKeyValue\u003e"
              }
            ],
            "Documentation": [
              " Set some items of storage.",
              "",
              " # \u003cweight\u003e",
              " - `O(I)` where `I` length of `items`",
              " - `I` storage writes (`O(1)`).",
              " - Base Weight: 0.568 * i µs",
              " - Writes: Number of items",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "kill_storage",
            "Args": [
              {
                "Name": "keys",
                "Type": "Vec\u003cKey\u003e"
              }
            ],
            "Documentation": [
              " Kill some items from storage.",
              "",
              " # \u003cweight\u003e",
              " - `O(IK)` where `I` length of `keys` and `K` length of one key",
              " - `I` storage deletions.",
              " - Base Weight: .378 * i µs",
              " - Writes: Number of items",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "kill_prefix",
            "Args": [
              {
                "Name": "prefix",
                "Type": "Key"
              },
              {
                "Name": "_subkeys",
                "Type": "u32"
              }
            ],
            "Documentation": [
              " Kill all storage items with a key that starts with the given prefix.",
              "",
              " **NOTE:** We rely on the Root origin to provide us the number of subkeys under",
              " the prefix we are removing to accurately calculate the weight of this function.",
              "",
              " # \u003cweight\u003e",
              " - `O(P)` where `P` amount of keys with prefix `prefix`",
              " - `P` storage deletions.",
              " - Base Weight: 0.834 * P µs",
              " - Writes: Number of subkeys + 1",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "remark_with_event",
            "Args": [
              {
                "Name": "remark",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Make some on-chain remark and emit event.",
              "",
              " # \u003cweight\u003e",
              " - `O(b)` where b is the length of the remark.",
              " - 1 event.",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "ExtrinsicSuccess",
            "Args": [
              "DispatchInfo"
            ],
            "Documentation": [
              " An extrinsic completed successfully. \\[info\\]"
            ]
          },
          {
            "Name": "ExtrinsicFailed",
            "Args": [
              "DispatchError",
              "DispatchInfo"
            ],
            "Documentation": [
              " An extrinsic failed. \\[error, info\\]"
            ]
          },
          {
            "Name": "CodeUpdated",
            "Args": null,
            "Documentation": [
              " `:code` was updated."
            ]
          },
          {
            "Name": "NewAccount",
            "Args": [
              "AccountId"
            ],
            "Documentation": [
              " A new \\[account\\] was created."
            ]
          },
          {
            "Name": "KilledAccount",
            "Args": [
              "AccountId"
            ],
            "Documentation": [
              " An \\[account\\] was reaped."
            ]
          },
          {
            "Name": "Remarked",
            "Args": [
              "AccountId",
              "Hash"
            ],
            "Documentation": [
              " On on-chain remark happened. \\[origin, remark_hash\\]"
            ]
          }
        ],
        "Constants": [
          {
            "Name": "BlockWeights",
            "Type": "limits::BlockWeights",
            "Value": "APIFKgEAAAAAiFJqdAAAAEBZcwcAAAAAAcAYD6RLAAAAAQDmvU9XAAAAAQAAAAAAAAAAQFlzBwAAAAABwLqjvmgAAAABAIhSanQAAAABAKKUGh0AAABAWXMHAAAAAAAAAA==",
            "Documentation": [
              " Block \u0026 extrinsics weights: base values and limits."
            ]
          },
          {
            "Name": "BlockLength",
            "Type": "limits::BlockLength",
            "Value": "AAA8AAAAUAAAAFAA",
            "Documentation": [
              " The maximum length of a block (in bytes)."
            ]
          },
          {
            "Name": "BlockHashCount",
            "Type": "T::BlockNumber",
            "Value": "+gAAAA==",
            "Documentation": [
              " Maximum number of block number to block hash mappings to keep (oldest pruned first)."
            ]
          },
          {
            "Name": "DbWeight",
            "Type": "RuntimeDbWeight",
            "Value": "QHh9AQAAAAAA4fUFAAAAAA==",
            "Documentation": [
              " The weight of runtime database operations the runtime can invoke."
            ]
          },
          {
            "Name": "Version",
            "Type": "RuntimeVersion",
            "Value": "JG1vb25yaXZlciRtb29ucml2ZXIDAAAAMQAAAAEAAAA032rLaJkHYJsDAAAAN+OX/HyR9eQBAAAAQP461AH4lZoFAAAA0ryYl+7QjxUCAAAA94sni+U/RUwCAAAAqzwFcikf64sBAAAAvJ2JkE9bkj8BAAAAvXglXU/u6h8BAAAAoz1D9YcxrYQBAAAAWCIR9luxS4kBAAAAN8i7E1CpoqgBAAAAH7o/+7fgfo0BAAAA6pPj8W89aWIBAAAAAgAAAA==",
            "Documentation": [
              " Get the chain's current version."
            ]
          },
          {
            "Name": "SS58Prefix",
            "Type": "u8",
            "Value": "MQ==",
            "Documentation": [
              " The designated SS85 prefix of this chain.",
              "",
              " This replaces the \"ss58Format\" property declared in the chain spec. Reason is",
              " that the runtime should know about the prefix in order to make use of it as",
              " an identifier of the chain."
            ]
          }
        ],
        "Errors": [
          {
            "Name": "InvalidSpecName",
            "Documentation": [
              " The name of specification does not match between the current runtime",
              " and the new runtime."
            ]
          },
          {
            "Name": "SpecVersionNeedsToIncrease",
            "Documentation": [
              " The specification version is not allowed to decrease between the current runtime",
              " and the new runtime."
            ]
          },
          {
            "Name": "FailedToExtractRuntimeVersion",
            "Documentation": [
              " Failed to extract the runtime version from the new runtime.",
              "",
              " Either calling `Core_version` or decoding `RuntimeVersion` failed."
            ]
          },
          {
            "Name": "NonDefaultComposite",
            "Documentation": [
              " Suicide called when the account has non-default composite data."
            ]
          },
          {
            "Name": "NonZeroRefCount",
            "Documentation": [
              " There is a non-zero reference count preventing the account from being purged."
            ]
          }
        ],
        "Index": 0
      },
      {
        "Name": "ParachainSystem",
        "HasStorage": true,
        "Storage": {
          "Prefix": "ParachainSystem",
          "Items": [
            {
              "Name": "PendingRelayChainBlockNumber",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "RelayChainBlockNumber",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " We need to store the new validation function for the span between",
                " setting it and applying it. If it has a",
                " value, then [`PendingValidationCode`] must have a real value, and",
                " together will coordinate the block number where the upgrade will happen."
              ]
            },
            {
              "Name": "PendingValidationCode",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cu8\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The new validation function we will upgrade to when the relay chain",
                " reaches [`PendingRelayChainBlockNumber`]. A real validation function must",
                " exist here as long as [`PendingRelayChainBlockNumber`] is set."
              ]
            },
            {
              "Name": "ValidationData",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "PersistedValidationData",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The [`PersistedValidationData`] set for this block."
              ]
            },
            {
              "Name": "DidSetValidationCode",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "bool",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Were the validation data set to notify the relay chain?"
              ]
            },
            {
              "Name": "LastUpgrade",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "relay_chain::BlockNumber",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " The last relay parent block number at which we signalled the code upgrade."
              ]
            },
            {
              "Name": "RelevantMessagingState",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "MessagingStateSnapshot",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The snapshot of some state related to messaging relevant to the current parachain as per",
                " the relay parent.",
                "",
                " This field is meant to be updated each block with the validation data inherent. Therefore,",
                " before processing of the inherent, e.g. in `on_initialize` this data may be stale.",
                "",
                " This data is also absent from the genesis."
              ]
            },
            {
              "Name": "HostConfiguration",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "AbridgedHostConfiguration",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The parachain host configuration that was obtained from the relay parent.",
                "",
                " This field is meant to be updated each block with the validation data inherent. Therefore,",
                " before processing of the inherent, e.g. in `on_initialize` this data may be stale.",
                "",
                " This data is also absent from the genesis."
              ]
            },
            {
              "Name": "LastDmqMqcHead",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "MessageQueueChain",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
              "Documentation": [
                " The last downward message queue chain head we have observed.",
                "",
                " This value is loaded before and saved after processing inbound downward messages carried",
                " by the system inherent."
              ]
            },
            {
              "Name": "LastHrmpMqcHeads",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "BTreeMap\u003cParaId, MessageQueueChain\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The message queue chain heads we have observed per each channel incoming channel.",
                "",
                " This value is loaded before and saved after processing inbound downward messages carried",
                " by the system inherent."
              ]
            },
            {
              "Name": "ProcessedDownwardMessages",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u32",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Number of downward messages processed in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "Name": "NewValidationCode",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cu8\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " New validation code that was set in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block if no other pallet already set",
                " the value."
              ]
            },
            {
              "Name": "HrmpWatermark",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "relay_chain::v1::BlockNumber",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " HRMP watermark that was set in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "Name": "HrmpOutboundMessages",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cOutboundHrmpMessage\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " HRMP messages that were sent in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "Name": "UpwardMessages",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cUpwardMessage\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Upward messages that were sent in a block.",
                "",
                " This will be cleared in `on_initialize` of each new block."
              ]
            },
            {
              "Name": "PendingUpwardMessages",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cUpwardMessage\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Upward messages that are still pending and not yet send to the relay chain."
              ]
            },
            {
              "Name": "AnnouncedHrmpMessagesPerCandidate",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u32",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " The number of HRMP messages we observed in `on_initialize` and thus used that number for",
                " announcing the weight of `on_initialize` and `on_finalize`."
              ]
            },
            {
              "Name": "ReservedXcmpWeightOverride",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Weight",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The weight we reserve at the beginning of the block for processing XCMP messages. This",
                " overrides the amount set in the Config trait."
              ]
            },
            {
              "Name": "ReservedDmpWeightOverride",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Weight",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The weight we reserve at the beginning of the block for processing DMP messages. This",
                " overrides the amount set in the Config trait."
              ]
            },
            {
              "Name": "AuthorizedUpgrade",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::Hash",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The next authorized upgrade, if there is one."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "set_upgrade_block",
            "Args": [
              {
                "Name": "relay_chain_block",
                "Type": "RelayChainBlockNumber"
              }
            ],
            "Documentation": [
              " Force an already scheduled validation function upgrade to happen on a particular block.",
              "",
              " Note that coordinating this block for the upgrade has to happen independently on the",
              " relay chain and this parachain. Synchronizing the block for the upgrade is sensitive,",
              " and this bypasses all checks and and normal protocols. Very easy to brick your chain",
              " if done wrong."
            ]
          },
          {
            "Name": "set_validation_data",
            "Args": [
              {
                "Name": "data",
                "Type": "ParachainInherentData"
              }
            ],
            "Documentation": [
              " Set the current validation data.",
              "",
              " This should be invoked exactly once per block. It will panic at the finalization",
              " phase if the call was not invoked.",
              "",
              " The dispatch origin for this call must be `Inherent`",
              "",
              " As a side effect, this function upgrades the current validation function",
              " if the appropriate time has come."
            ]
          },
          {
            "Name": "sudo_send_upward_message",
            "Args": [
              {
                "Name": "message",
                "Type": "UpwardMessage"
              }
            ],
            "Documentation": null
          },
          {
            "Name": "authorize_upgrade",
            "Args": [
              {
                "Name": "code_hash",
                "Type": "T::Hash"
              }
            ],
            "Documentation": null
          },
          {
            "Name": "enact_authorized_upgrade",
            "Args": [
              {
                "Name": "code",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": null
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "ValidationFunctionStored",
            "Args": [
              "RelayChainBlockNumber"
            ],
            "Documentation": [
              " The validation function has been scheduled to apply as of the contained relay chain",
              " block number."
            ]
          },
          {
            "Name": "ValidationFunctionApplied",
            "Args": [
              "RelayChainBlockNumber"
            ],
            "Documentation": [
              " The validation function was applied as of the contained relay chain block number."
            ]
          },
          {
            "Name": "UpgradeAuthorized",
            "Args": [
              "Hash"
            ],
            "Documentation": [
              " An upgrade has been authorized."
            ]
          },
          {
            "Name": "DownwardMessagesReceived",
            "Args": [
              "u32"
            ],
            "Documentation": [
              " Some downward messages have been received and will be processed.",
              " \\[ count \\]"
            ]
          },
          {
            "Name": "DownwardMessagesProcessed",
            "Args": [
              "Weight",
              "relay_chain::Hash"
            ],
            "Documentation": [
              " Downward messages were processed using the given weight.",
              " \\[ weight_used, result_mqc_head \\]"
            ]
          }
        ],
        "Constants": null,
        "Errors": [
          {
            "Name": "OverlappingUpgrades",
            "Documentation": [
              " Attempt to upgrade validation function while existing upgrade pending"
            ]
          },
          {
            "Name": "ProhibitedByPolkadot",
            "Documentation": [
              " Polkadot currently prohibits this parachain from upgrading its validation function"
            ]
          },
          {
            "Name": "TooBig",
            "Documentation": [
              " The supplied validation function has compiled into a blob larger than Polkadot is",
              " willing to run"
            ]
          },
          {
            "Name": "ValidationDataNotAvailable",
            "Documentation": [
              " The inherent which supplies the validation data did not run this block"
            ]
          },
          {
            "Name": "HostConfigurationNotAvailable",
            "Documentation": [
              " The inherent which supplies the host configuration did not run this block"
            ]
          },
          {
            "Name": "NotScheduled",
            "Documentation": [
              " No validation function upgrade is currently scheduled."
            ]
          },
          {
            "Name": "NothingAuthorized",
            "Documentation": [
              " No code upgrade has been authorized."
            ]
          },
          {
            "Name": "Unauthorized",
            "Documentation": [
              " The given code upgrade has not been authorized."
            ]
          }
        ],
        "Index": 1
      },
      {
        "Name": "RandomnessCollectiveFlip",
        "HasStorage": true,
        "Storage": {
          "Prefix": "RandomnessCollectiveFlip",
          "Items": [
            {
              "Name": "RandomMaterial",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cT::Hash\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Series of block headers from the last 81 blocks that acts as random seed material. This",
                " is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of",
                " the oldest hash."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": null,
        "HasEvents": false,
        "Events": null,
        "Constants": null,
        "Errors": null,
        "Index": 2
      },
      {
        "Name": "Timestamp",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Timestamp",
          "Items": [
            {
              "Name": "Now",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::Moment",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAA=",
              "Documentation": [
                " Current time for the current block."
              ]
            },
            {
              "Name": "DidUpdate",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "bool",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Did the timestamp get updated in this block?"
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "set",
            "Args": [
              {
                "Name": "now",
                "Type": "Compact\u003cT::Moment\u003e"
              }
            ],
            "Documentation": [
              " Set the current time.",
              "",
              " This call should be invoked exactly once per block. It will panic at the finalization",
              " phase, if this call hasn't been invoked by that time.",
              "",
              " The timestamp should be greater than the previous one by the amount specified by",
              " `MinimumPeriod`.",
              "",
              " The dispatch origin for this call must be `Inherent`.",
              "",
              " # \u003cweight\u003e",
              " - `O(1)` (Note that implementations of `OnTimestampSet` must also be `O(1)`)",
              " - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`)",
              " - 1 event handler `on_timestamp_set`. Must be `O(1)`.",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": false,
        "Events": null,
        "Constants": [
          {
            "Name": "MinimumPeriod",
            "Type": "T::Moment",
            "Value": "AQAAAAAAAAA=",
            "Documentation": [
              " The minimum period between blocks. Beware that this is different to the *expected* period",
              " that the block production apparatus provides. Your chosen consensus system will generally",
              " work with this to determine a sensible block time. e.g. For Aura, it will be double this",
              " period on default settings."
            ]
          }
        ],
        "Errors": null,
        "Index": 3
      },
      {
        "Name": "ParachainInfo",
        "HasStorage": true,
        "Storage": {
          "Prefix": "ParachainInfo",
          "Items": [
            {
              "Name": "ParachainId",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "ParaId",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "ZAAAAA==",
              "Documentation": null
            }
          ]
        },
        "HasCalls": false,
        "Calls": null,
        "HasEvents": false,
        "Events": null,
        "Constants": null,
        "Errors": null,
        "Index": 4
      },
      {
        "Name": "Balances",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Balances",
          "Items": [
            {
              "Name": "TotalIssuance",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::Balance",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAA==",
              "Documentation": [
                " The total units issued in the system."
              ]
            },
            {
              "Name": "Account",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "AccountData\u003cT::Balance\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
              "Documentation": [
                " The balance of an account.",
                "",
                " NOTE: This is only used in the case that this pallet is used to store balances."
              ]
            },
            {
              "Name": "Locks",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "Vec\u003cBalanceLock\u003cT::Balance\u003e\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Any liquidity locks on some account balances.",
                " NOTE: Should only be accessed when setting, changing and freeing a lock."
              ]
            },
            {
              "Name": "StorageVersion",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Releases",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Storage version of the pallet.",
                "",
                " This is set to v2.0.0 for new networks."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "transfer",
            "Args": [
              {
                "Name": "dest",
                "Type": "\u003cT::Lookup as StaticLookup\u003e::Source"
              },
              {
                "Name": "value",
                "Type": "Compact\u003cT::Balance\u003e"
              }
            ],
            "Documentation": [
              " Transfer some liquid free balance to another account.",
              "",
              " `transfer` will set the `FreeBalance` of the sender and receiver.",
              " It will decrease the total issuance of the system by the `TransferFee`.",
              " If the sender's account is below the existential deposit as a result",
              " of the transfer, the account will be reaped.",
              "",
              " The dispatch origin for this call must be `Signed` by the transactor.",
              "",
              " # \u003cweight\u003e",
              " - Dependent on arguments but not critical, given proper implementations for",
              "   input config types. See related functions below.",
              " - It contains a limited number of reads and writes internally and no complex computation.",
              "",
              " Related functions:",
              "",
              "   - `ensure_can_withdraw` is always called internally but has a bounded complexity.",
              "   - Transferring balances to accounts that did not exist before will cause",
              "      `T::OnNewAccount::on_new_account` to be called.",
              "   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.",
              "   - `transfer_keep_alive` works the same way as `transfer`, but has an additional",
              "     check that the transfer will not kill the origin account.",
              " ---------------------------------",
              " - Base Weight: 73.64 µs, worst case scenario (account created, account removed)",
              " - DB Weight: 1 Read and 1 Write to destination account",
              " - Origin account is already in memory, so no DB operations for them.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "set_balance",
            "Args": [
              {
                "Name": "who",
                "Type": "\u003cT::Lookup as StaticLookup\u003e::Source"
              },
              {
                "Name": "new_free",
                "Type": "Compact\u003cT::Balance\u003e"
              },
              {
                "Name": "new_reserved",
                "Type": "Compact\u003cT::Balance\u003e"
              }
            ],
            "Documentation": [
              " Set the balances of a given account.",
              "",
              " This will alter `FreeBalance` and `ReservedBalance` in storage. it will",
              " also decrease the total issuance of the system (`TotalIssuance`).",
              " If the new free or reserved balance is below the existential deposit,",
              " it will reset the account nonce (`frame_system::AccountNonce`).",
              "",
              " The dispatch origin for this call is `root`.",
              "",
              " # \u003cweight\u003e",
              " - Independent of the arguments.",
              " - Contains a limited number of reads and writes.",
              " ---------------------",
              " - Base Weight:",
              "     - Creating: 27.56 µs",
              "     - Killing: 35.11 µs",
              " - DB Weight: 1 Read, 1 Write to `who`",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "force_transfer",
            "Args": [
              {
                "Name": "source",
                "Type": "\u003cT::Lookup as StaticLookup\u003e::Source"
              },
              {
                "Name": "dest",
                "Type": "\u003cT::Lookup as StaticLookup\u003e::Source"
              },
              {
                "Name": "value",
                "Type": "Compact\u003cT::Balance\u003e"
              }
            ],
            "Documentation": [
              " Exactly as `transfer`, except the origin must be root and the source account may be",
              " specified.",
              " # \u003cweight\u003e",
              " - Same as transfer, but additional read and write because the source account is",
              "   not assumed to be in the overlay.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "transfer_keep_alive",
            "Args": [
              {
                "Name": "dest",
                "Type": "\u003cT::Lookup as StaticLookup\u003e::Source"
              },
              {
                "Name": "value",
                "Type": "Compact\u003cT::Balance\u003e"
              }
            ],
            "Documentation": [
              " Same as the [`transfer`] call, but with a check that the transfer will not kill the",
              " origin account.",
              "",
              " 99% of the time you want [`transfer`] instead.",
              "",
              " [`transfer`]: struct.Pallet.html#method.transfer",
              " # \u003cweight\u003e",
              " - Cheaper than transfer because account cannot be killed.",
              " - Base Weight: 51.4 µs",
              " - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already)",
              " #\u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Endowed",
            "Args": [
              "AccountId",
              "Balance"
            ],
            "Documentation": [
              " An account was created with some free balance. \\[account, free_balance\\]"
            ]
          },
          {
            "Name": "DustLost",
            "Args": [
              "AccountId",
              "Balance"
            ],
            "Documentation": [
              " An account was removed whose balance was non-zero but below ExistentialDeposit,",
              " resulting in an outright loss. \\[account, balance\\]"
            ]
          },
          {
            "Name": "Transfer",
            "Args": [
              "AccountId",
              "AccountId",
              "Balance"
            ],
            "Documentation": [
              " Transfer succeeded. \\[from, to, value\\]"
            ]
          },
          {
            "Name": "BalanceSet",
            "Args": [
              "AccountId",
              "Balance",
              "Balance"
            ],
            "Documentation": [
              " A balance was set by root. \\[who, free, reserved\\]"
            ]
          },
          {
            "Name": "Deposit",
            "Args": [
              "AccountId",
              "Balance"
            ],
            "Documentation": [
              " Some amount was deposited (e.g. for transaction fees). \\[who, deposit\\]"
            ]
          },
          {
            "Name": "Reserved",
            "Args": [
              "AccountId",
              "Balance"
            ],
            "Documentation": [
              " Some balance was reserved (moved from free to reserved). \\[who, value\\]"
            ]
          },
          {
            "Name": "Unreserved",
            "Args": [
              "AccountId",
              "Balance"
            ],
            "Documentation": [
              " Some balance was unreserved (moved from reserved to free). \\[who, value\\]"
            ]
          },
          {
            "Name": "ReserveRepatriated",
            "Args": [
              "AccountId",
              "AccountId",
              "Balance",
              "Status"
            ],
            "Documentation": [
              " Some balance was moved from the reserve of the first account to the second account.",
              " Final argument indicates the destination balance type.",
              " \\[from, to, balance, destination_status\\]"
            ]
          }
        ],
        "Constants": [
          {
            "Name": "ExistentialDeposit",
            "Type": "T::Balance",
            "Value": "AAAAAAAAAAAAAAAAAAAAAA==",
            "Documentation": [
              " The minimum amount required to keep an account open."
            ]
          }
        ],
        "Errors": [
          {
            "Name": "VestingBalance",
            "Documentation": [
              " Vesting balance too high to send value"
            ]
          },
          {
            "Name": "LiquidityRestrictions",
            "Documentation": [
              " Account liquidity restrictions prevent withdrawal"
            ]
          },
          {
            "Name": "InsufficientBalance",
            "Documentation": [
              " Balance too low to send value"
            ]
          },
          {
            "Name": "ExistentialDeposit",
            "Documentation": [
              " Value too low to create account due to existential deposit"
            ]
          },
          {
            "Name": "KeepAlive",
            "Documentation": [
              " Transfer/payment would kill account"
            ]
          },
          {
            "Name": "ExistingVestingSchedule",
            "Documentation": [
              " A vesting schedule already exists for this account"
            ]
          },
          {
            "Name": "DeadAccount",
            "Documentation": [
              " Beneficiary account must pre-exist"
            ]
          }
        ],
        "Index": 10
      },
      {
        "Name": "TransactionPayment",
        "HasStorage": true,
        "Storage": {
          "Prefix": "TransactionPayment",
          "Items": [
            {
              "Name": "NextFeeMultiplier",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Multiplier",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AABkp7O24A0AAAAAAAAAAA==",
              "Documentation": null
            },
            {
              "Name": "StorageVersion",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Releases",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": null
            }
          ]
        },
        "HasCalls": false,
        "Calls": null,
        "HasEvents": false,
        "Events": null,
        "Constants": [
          {
            "Name": "TransactionByteFee",
            "Type": "BalanceOf\u003cT\u003e",
            "Value": "AKByThgJAAAAAAAAAAAAAA==",
            "Documentation": [
              " The fee to be paid for making a transaction; the per-byte portion."
            ]
          },
          {
            "Name": "WeightToFee",
            "Type": "Vec\u003cWeightToFeeCoefficient\u003cBalanceOf\u003cT\u003e\u003e\u003e",
            "Value": "BAEAAAAAAAAAAAAAAAAAAAAAAAAAAAE=",
            "Documentation": [
              " The polynomial that is applied in order to derive fee from weight."
            ]
          }
        ],
        "Errors": null,
        "Index": 11
      },
      {
        "Name": "ParachainStaking",
        "HasStorage": true,
        "Storage": {
          "Prefix": "ParachainStaking",
          "Items": [
            {
              "Name": "CollatorCommission",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Perbill",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Commission percent taken off of rewards for all collators"
              ]
            },
            {
              "Name": "TotalSelected",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u32",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " The total candidates selected every round"
              ]
            },
            {
              "Name": "ParachainBondInfo",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "ParachainBondConfig\u003cT::AccountId\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAA",
              "Documentation": [
                " Parachain bond config info { account, percent_of_inflation }"
              ]
            },
            {
              "Name": "Round",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "RoundInfo\u003cT::BlockNumber\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AQAAAAEAAAAUAAAA",
              "Documentation": [
                " Current round index and next round scheduled transition"
              ]
            },
            {
              "Name": "NominatorState",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "Nominator\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Get nominator state associated with an account if account is nominating else None"
              ]
            },
            {
              "Name": "CollatorState",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "Collator\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Get collator state associated with an account if account is collating else None"
              ]
            },
            {
              "Name": "SelectedCandidates",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cT::AccountId\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The collator candidates selected for the current round"
              ]
            },
            {
              "Name": "Total",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "BalanceOf\u003cT\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAA==",
              "Documentation": [
                " Total capital locked by this staking pallet"
              ]
            },
            {
              "Name": "CandidatePool",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "OrderedSet\u003cBond\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The pool of collator candidates, each with their total backing stake"
              ]
            },
            {
              "Name": "ExitQueue",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "OrderedSet\u003cBond\u003cT::AccountId, RoundIndex\u003e\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " A queue of collators awaiting exit `BondDuration` delay after request"
              ]
            },
            {
              "Name": "AtStake",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": true,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key1": "RoundIndex",
                  "Key2": "T::AccountId",
                  "Value": "CollatorSnapshot\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
              "Documentation": [
                " Snapshot of collator nomination stake at the start of the round"
              ]
            },
            {
              "Name": "Staked",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "RoundIndex",
                  "Value": "BalanceOf\u003cT\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAA==",
              "Documentation": [
                " Total backing stake for selected candidates in the round"
              ]
            },
            {
              "Name": "InflationConfig",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "InflationInfo\u003cBalanceOf\u003cT\u003e\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
              "Documentation": [
                " Inflation configuration"
              ]
            },
            {
              "Name": "Points",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "RoundIndex",
                  "Value": "RewardPoint",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Total points awarded to collators for block production in the round"
              ]
            },
            {
              "Name": "AwardedPts",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": true,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key1": "RoundIndex",
                  "Key2": "T::AccountId",
                  "Value": "RewardPoint",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Points for each collator per round"
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "set_staking_expectations",
            "Args": [
              {
                "Name": "expectations",
                "Type": "Range\u003cBalanceOf\u003cT\u003e\u003e"
              }
            ],
            "Documentation": [
              " Set the expectations for total staked. These expectations determine the issuance for",
              " the round according to logic in `fn compute_issuance`"
            ]
          },
          {
            "Name": "set_inflation",
            "Args": [
              {
                "Name": "schedule",
                "Type": "Range\u003cPerbill\u003e"
              }
            ],
            "Documentation": [
              " Set the annual inflation rate to derive per-round inflation"
            ]
          },
          {
            "Name": "set_parachain_bond_account",
            "Args": [
              {
                "Name": "new",
                "Type": "T::AccountId"
              }
            ],
            "Documentation": [
              " Set the account that will hold funds set aside for parachain bond"
            ]
          },
          {
            "Name": "set_parachain_bond_reserve_percent",
            "Args": [
              {
                "Name": "new",
                "Type": "Percent"
              }
            ],
            "Documentation": [
              " Set the percent of inflation set aside for parachain bond"
            ]
          },
          {
            "Name": "set_total_selected",
            "Args": [
              {
                "Name": "new",
                "Type": "u32"
              }
            ],
            "Documentation": [
              " Set the total number of collator candidates selected per round",
              " - changes are not applied until the start of the next round"
            ]
          },
          {
            "Name": "set_collator_commission",
            "Args": [
              {
                "Name": "pct",
                "Type": "Perbill"
              }
            ],
            "Documentation": [
              " Set the commission for all collators"
            ]
          },
          {
            "Name": "set_blocks_per_round",
            "Args": [
              {
                "Name": "new",
                "Type": "u32"
              }
            ],
            "Documentation": [
              " Set blocks per round",
              " - if called with `new` less than length of current round, will transition immediately",
              " in the next block",
              " - also updates per-round inflation config"
            ]
          },
          {
            "Name": "join_candidates",
            "Args": [
              {
                "Name": "bond",
                "Type": "BalanceOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Join the set of collator candidates"
            ]
          },
          {
            "Name": "leave_candidates",
            "Args": null,
            "Documentation": [
              " Request to leave the set of candidates. If successful, the account is immediately",
              " removed from the candidate pool to prevent selection as a collator, but unbonding is",
              " executed with a delay of `BondDuration` rounds."
            ]
          },
          {
            "Name": "go_offline",
            "Args": null,
            "Documentation": [
              " Temporarily leave the set of collator candidates without unbonding"
            ]
          },
          {
            "Name": "go_online",
            "Args": null,
            "Documentation": [
              " Rejoin the set of collator candidates if previously had called `go_offline`"
            ]
          },
          {
            "Name": "candidate_bond_more",
            "Args": [
              {
                "Name": "more",
                "Type": "BalanceOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Bond more for collator candidates"
            ]
          },
          {
            "Name": "candidate_bond_less",
            "Args": [
              {
                "Name": "less",
                "Type": "BalanceOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Bond less for collator candidates"
            ]
          },
          {
            "Name": "nominate",
            "Args": [
              {
                "Name": "collator",
                "Type": "T::AccountId"
              },
              {
                "Name": "amount",
                "Type": "BalanceOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " If caller is not a nominator, then join the set of nominators",
              " If caller is a nominator, then makes nomination to change their nomination state"
            ]
          },
          {
            "Name": "leave_nominators",
            "Args": null,
            "Documentation": [
              " Leave the set of nominators and, by implication, revoke all ongoing nominations"
            ]
          },
          {
            "Name": "revoke_nomination",
            "Args": [
              {
                "Name": "collator",
                "Type": "T::AccountId"
              }
            ],
            "Documentation": [
              " Revoke an existing nomination"
            ]
          },
          {
            "Name": "nominator_bond_more",
            "Args": [
              {
                "Name": "candidate",
                "Type": "T::AccountId"
              },
              {
                "Name": "more",
                "Type": "BalanceOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Bond more for nominators with respect to a specific collator candidate"
            ]
          },
          {
            "Name": "nominator_bond_less",
            "Args": [
              {
                "Name": "candidate",
                "Type": "T::AccountId"
              },
              {
                "Name": "less",
                "Type": "BalanceOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Bond less for nominators with respect to a specific nominator candidate"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "NewRound",
            "Args": [
              "T::BlockNumber",
              "RoundIndex",
              "u32",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Starting Block, Round, Number of Collators Selected, Total Balance"
            ]
          },
          {
            "Name": "JoinedCollatorCandidates",
            "Args": [
              "T::AccountId",
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Account, Amount Locked, New Total Amt Locked"
            ]
          },
          {
            "Name": "CollatorChosen",
            "Args": [
              "RoundIndex",
              "T::AccountId",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Round, Collator Account, Total Exposed Amount (includes all nominations)"
            ]
          },
          {
            "Name": "CollatorBondedMore",
            "Args": [
              "T::AccountId",
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Collator Account, Old Bond, New Bond"
            ]
          },
          {
            "Name": "CollatorBondedLess",
            "Args": [
              "T::AccountId",
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Collator Account, Old Bond, New Bond"
            ]
          },
          {
            "Name": "CollatorWentOffline",
            "Args": [
              "RoundIndex",
              "T::AccountId"
            ],
            "Documentation": null
          },
          {
            "Name": "CollatorBackOnline",
            "Args": [
              "RoundIndex",
              "T::AccountId"
            ],
            "Documentation": null
          },
          {
            "Name": "CollatorScheduledExit",
            "Args": [
              "RoundIndex",
              "T::AccountId",
              "RoundIndex"
            ],
            "Documentation": [
              " Round, Collator Account, Scheduled Exit"
            ]
          },
          {
            "Name": "CollatorLeft",
            "Args": [
              "T::AccountId",
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Account, Amount Unlocked, New Total Amt Locked"
            ]
          },
          {
            "Name": "NominationIncreased",
            "Args": [
              "T::AccountId",
              "T::AccountId",
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": null
          },
          {
            "Name": "NominationDecreased",
            "Args": [
              "T::AccountId",
              "T::AccountId",
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": null
          },
          {
            "Name": "NominatorLeft",
            "Args": [
              "T::AccountId",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Nominator, Amount Unstaked"
            ]
          },
          {
            "Name": "Nomination",
            "Args": [
              "T::AccountId",
              "BalanceOf\u003cT\u003e",
              "T::AccountId",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Nominator, Amount Locked, Collator, New Total Amt backing Collator"
            ]
          },
          {
            "Name": "NominatorLeftCollator",
            "Args": [
              "T::AccountId",
              "T::AccountId",
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Nominator, Collator, Amount Unstaked, New Total Amt Staked for Collator"
            ]
          },
          {
            "Name": "Rewarded",
            "Args": [
              "T::AccountId",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Paid the account (nominator or collator) the balance as liquid rewards"
            ]
          },
          {
            "Name": "ReservedForParachainBond",
            "Args": [
              "T::AccountId",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Transferred to account which holds funds reserved for parachain bond"
            ]
          },
          {
            "Name": "ParachainBondAccountSet",
            "Args": [
              "T::AccountId",
              "T::AccountId"
            ],
            "Documentation": [
              " Account (re)set for parachain bond treasury [old, new]"
            ]
          },
          {
            "Name": "ParachainBondReservePercentSet",
            "Args": [
              "Percent",
              "Percent"
            ],
            "Documentation": [
              " Percent of inflation reserved for parachain bond (re)set [old, new]"
            ]
          },
          {
            "Name": "InflationSet",
            "Args": [
              "Perbill",
              "Perbill",
              "Perbill",
              "Perbill",
              "Perbill",
              "Perbill"
            ],
            "Documentation": [
              " Annual inflation input (first 3) was used to derive new per-round inflation (last 3)"
            ]
          },
          {
            "Name": "StakeExpectationsSet",
            "Args": [
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Staking expectations set"
            ]
          },
          {
            "Name": "TotalSelectedSet",
            "Args": [
              "u32",
              "u32"
            ],
            "Documentation": [
              " Set total selected candidates to this value [old, new]"
            ]
          },
          {
            "Name": "CollatorCommissionSet",
            "Args": [
              "Perbill",
              "Perbill"
            ],
            "Documentation": [
              " Set collator commission to this value [old, new]"
            ]
          },
          {
            "Name": "BlocksPerRoundSet",
            "Args": [
              "RoundIndex",
              "T::BlockNumber",
              "u32",
              "u32",
              "Perbill",
              "Perbill",
              "Perbill"
            ],
            "Documentation": [
              " Set blocks per round [current_round, first_block, old, new, new_per_round_inflation]"
            ]
          }
        ],
        "Constants": null,
        "Errors": [
          {
            "Name": "NominatorDNE",
            "Documentation": null
          },
          {
            "Name": "CandidateDNE",
            "Documentation": null
          },
          {
            "Name": "NominatorExists",
            "Documentation": null
          },
          {
            "Name": "CandidateExists",
            "Documentation": null
          },
          {
            "Name": "ValBondBelowMin",
            "Documentation": null
          },
          {
            "Name": "NomBondBelowMin",
            "Documentation": null
          },
          {
            "Name": "NominationBelowMin",
            "Documentation": null
          },
          {
            "Name": "AlreadyOffline",
            "Documentation": null
          },
          {
            "Name": "AlreadyActive",
            "Documentation": null
          },
          {
            "Name": "AlreadyLeaving",
            "Documentation": null
          },
          {
            "Name": "TooManyNominators",
            "Documentation": null
          },
          {
            "Name": "CannotActivateIfLeaving",
            "Documentation": null
          },
          {
            "Name": "ExceedMaxCollatorsPerNom",
            "Documentation": null
          },
          {
            "Name": "AlreadyNominatedCollator",
            "Documentation": null
          },
          {
            "Name": "NominationDNE",
            "Documentation": null
          },
          {
            "Name": "Underflow",
            "Documentation": null
          },
          {
            "Name": "InvalidSchedule",
            "Documentation": null
          },
          {
            "Name": "CannotSetBelowMin",
            "Documentation": null
          }
        ],
        "Index": 20
      },
      {
        "Name": "AuthorInherent",
        "HasStorage": true,
        "Storage": {
          "Prefix": "AuthorInherent",
          "Items": [
            {
              "Name": "Author",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::AccountId",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Author of current block."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "set_author",
            "Args": [
              {
                "Name": "author",
                "Type": "T::AuthorId"
              }
            ],
            "Documentation": [
              " Inherent to set the author of a block"
            ]
          }
        ],
        "HasEvents": false,
        "Events": null,
        "Constants": null,
        "Errors": [
          {
            "Name": "AuthorAlreadySet",
            "Documentation": [
              " Author already set in block."
            ]
          },
          {
            "Name": "NoAccountId",
            "Documentation": [
              " No AccountId was found to be associated with this author"
            ]
          },
          {
            "Name": "CannotBeAuthor",
            "Documentation": [
              " The author in the inherent is not an eligible author."
            ]
          }
        ],
        "Index": 21
      },
      {
        "Name": "AuthorFilter",
        "HasStorage": true,
        "Storage": {
          "Prefix": "AuthorFilter",
          "Items": [
            {
              "Name": "EligibleRatio",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Percent",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "Mg==",
              "Documentation": [
                " The percentage of active authors that will be eligible at each height."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "set_eligible",
            "Args": [
              {
                "Name": "new",
                "Type": "Percent"
              }
            ],
            "Documentation": [
              " Update the eligible ratio. Intended to be called by governance."
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "EligibleUpdated",
            "Args": [
              "Percent"
            ],
            "Documentation": [
              " The amount of eligible authors for the filter to select has been changed."
            ]
          }
        ],
        "Constants": null,
        "Errors": null,
        "Index": 22
      },
      {
        "Name": "AuthorMapping",
        "HasStorage": true,
        "Storage": {
          "Prefix": "AuthorMapping",
          "Items": [
            {
              "Name": "MappingWithDeposit",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::AuthorId",
                  "Value": "RegistrationInfo\u003cT::AccountId, BalanceOf\u003cT\u003e\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " We maintain a mapping from the AuthorIds used in the consensus layer",
                " to the AccountIds runtime (including this staking pallet)."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "add_association",
            "Args": [
              {
                "Name": "author_id",
                "Type": "T::AuthorId"
              }
            ],
            "Documentation": [
              " Register your AuthorId onchain so blocks you author are associated with your account.",
              "",
              " Users who have been (or will soon be) elected active collators in staking,",
              " should submit this extrinsic to have their blocks accepted and earn rewards."
            ]
          },
          {
            "Name": "update_association",
            "Args": [
              {
                "Name": "old_author_id",
                "Type": "T::AuthorId"
              },
              {
                "Name": "new_author_id",
                "Type": "T::AuthorId"
              }
            ],
            "Documentation": [
              " Change your AuthorId.",
              "",
              " This is useful for normal key rotation or for when switching from one physical collator",
              " machine to another. No new security deposit is required."
            ]
          },
          {
            "Name": "clear_association",
            "Args": [
              {
                "Name": "author_id",
                "Type": "T::AuthorId"
              }
            ],
            "Documentation": [
              " Clear your AuthorId.",
              "",
              " This is useful when you are no longer an author and would like to re-claim your security",
              " deposit."
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "AuthorRegistered",
            "Args": [
              "T::AuthorId",
              "T::AccountId"
            ],
            "Documentation": [
              " An AuthorId has been registered and mapped to an AccountId."
            ]
          },
          {
            "Name": "AuthorDeRegistered",
            "Args": [
              "T::AuthorId"
            ],
            "Documentation": [
              " An AuthorId has been de-registered, and its AccountId mapping removed."
            ]
          },
          {
            "Name": "AuthorRotated",
            "Args": [
              "T::AuthorId",
              "T::AccountId"
            ],
            "Documentation": [
              " An AuthorId has been registered, replacing a previous registration and its mapping."
            ]
          },
          {
            "Name": "DefunctAuthorBusted",
            "Args": [
              "T::AuthorId",
              "T::AccountId"
            ],
            "Documentation": [
              " An AuthorId has been forcibly deregistered after not being rotated or cleaned up.",
              " The reporteing account has been rewarded accordingly."
            ]
          }
        ],
        "Constants": null,
        "Errors": [
          {
            "Name": "AssociationNotFound",
            "Documentation": [
              " The association can't be cleared because it is not found."
            ]
          },
          {
            "Name": "NotYourAssociation",
            "Documentation": [
              " The association can't be cleared because it belongs to another account."
            ]
          },
          {
            "Name": "CannotSetAuthor",
            "Documentation": [
              " This account cannot set an author because it fails the preliminary check"
            ]
          },
          {
            "Name": "CannotAffordSecurityDeposit",
            "Documentation": [
              " This account cannot set an author because it cannon afford the security deposit"
            ]
          },
          {
            "Name": "AlreadyAssociated",
            "Documentation": [
              " The AuthorId in question is already associated and cannot be overwritten"
            ]
          }
        ],
        "Index": 23
      },
      {
        "Name": "Utility",
        "HasStorage": false,
        "Storage": {
          "Prefix": "",
          "Items": null
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "batch",
            "Args": [
              {
                "Name": "calls",
                "Type": "Vec\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Send a batch of dispatch calls.",
              "",
              " May be called from any origin.",
              "",
              " - `calls`: The calls to be dispatched from the same origin.",
              "",
              " If origin is root then call are dispatch without checking origin filter. (This includes",
              " bypassing `frame_system::Config::BaseCallFilter`).",
              "",
              " # \u003cweight\u003e",
              " - Complexity: O(C) where C is the number of calls to be batched.",
              " # \u003c/weight\u003e",
              "",
              " This will return `Ok` in all circumstances. To determine the success of the batch, an",
              " event is deposited. If a call failed and the batch was interrupted, then the",
              " `BatchInterrupted` event is deposited, along with the number of successful calls made",
              " and the error of the failed call. If all were successful, then the `BatchCompleted`",
              " event is deposited."
            ]
          },
          {
            "Name": "as_derivative",
            "Args": [
              {
                "Name": "index",
                "Type": "u16"
              },
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Send a call through an indexed pseudonym of the sender.",
              "",
              " Filter from origin are passed along. The call will be dispatched with an origin which",
              " use the same filter as the origin of this call.",
              "",
              " NOTE: If you need to ensure that any account-based filtering is not honored (i.e.",
              " because you expect `proxy` to have been used prior in the call stack and you do not want",
              " the call restrictions to apply to any sub-accounts), then use `as_multi_threshold_1`",
              " in the Multisig pallet instead.",
              "",
              " NOTE: Prior to version *12, this was called `as_limited_sub`.",
              "",
              " The dispatch origin for this call must be _Signed_."
            ]
          },
          {
            "Name": "batch_all",
            "Args": [
              {
                "Name": "calls",
                "Type": "Vec\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Send a batch of dispatch calls and atomically execute them.",
              " The whole transaction will rollback and fail if any of the calls failed.",
              "",
              " May be called from any origin.",
              "",
              " - `calls`: The calls to be dispatched from the same origin.",
              "",
              " If origin is root then call are dispatch without checking origin filter. (This includes",
              " bypassing `frame_system::Config::BaseCallFilter`).",
              "",
              " # \u003cweight\u003e",
              " - Complexity: O(C) where C is the number of calls to be batched.",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "BatchInterrupted",
            "Args": [
              "u32",
              "DispatchError"
            ],
            "Documentation": [
              " Batch of dispatches did not complete fully. Index of first failing dispatch given, as",
              " well as the error. \\[index, error\\]"
            ]
          },
          {
            "Name": "BatchCompleted",
            "Args": null,
            "Documentation": [
              " Batch of dispatches completed fully with no error."
            ]
          }
        ],
        "Constants": null,
        "Errors": null,
        "Index": 30
      },
      {
        "Name": "Proxy",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Proxy",
          "Items": [
            {
              "Name": "Proxies",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "(Vec\u003cProxyDefinition\u003cT::AccountId, T::ProxyType, T::BlockNumber\u003e\u003e,\n BalanceOf\u003cT\u003e)",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAA=",
              "Documentation": [
                " The set of account proxies. Maps the account which has delegated to the accounts",
                " which are being delegated to, together with the amount held on deposit."
              ]
            },
            {
              "Name": "Announcements",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "(Vec\u003cAnnouncement\u003cT::AccountId, CallHashOf\u003cT\u003e, T::BlockNumber\u003e\u003e,\n BalanceOf\u003cT\u003e)",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAA=",
              "Documentation": [
                " The announcements made by the proxy (key)."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "proxy",
            "Args": [
              {
                "Name": "real",
                "Type": "T::AccountId"
              },
              {
                "Name": "force_proxy_type",
                "Type": "Option\u003cT::ProxyType\u003e"
              },
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Dispatch the given `call` from an account that the sender is authorised for through",
              " `add_proxy`.",
              "",
              " Removes any corresponding announcement(s).",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `real`: The account that the proxy will make a call on behalf of.",
              " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.",
              " - `call`: The call to be made by the `real` account.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of the number of proxies the user has (P).",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "add_proxy",
            "Args": [
              {
                "Name": "delegate",
                "Type": "T::AccountId"
              },
              {
                "Name": "proxy_type",
                "Type": "T::ProxyType"
              },
              {
                "Name": "delay",
                "Type": "T::BlockNumber"
              }
            ],
            "Documentation": [
              " Register a proxy account for the sender that is able to make calls on its behalf.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `proxy`: The account that the `caller` would like to make a proxy.",
              " - `proxy_type`: The permissions allowed for this proxy account.",
              " - `delay`: The announcement period required of the initial proxy. Will generally be",
              " zero.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of the number of proxies the user has (P).",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "remove_proxy",
            "Args": [
              {
                "Name": "delegate",
                "Type": "T::AccountId"
              },
              {
                "Name": "proxy_type",
                "Type": "T::ProxyType"
              },
              {
                "Name": "delay",
                "Type": "T::BlockNumber"
              }
            ],
            "Documentation": [
              " Unregister a proxy account for the sender.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `proxy`: The account that the `caller` would like to remove as a proxy.",
              " - `proxy_type`: The permissions currently enabled for the removed proxy account.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of the number of proxies the user has (P).",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "remove_proxies",
            "Args": null,
            "Documentation": [
              " Unregister all proxy accounts for the sender.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " WARNING: This may be called on accounts created by `anonymous`, however if done, then",
              " the unreserved fees will be inaccessible. **All access to this account will be lost.**",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of the number of proxies the user has (P).",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "anonymous",
            "Args": [
              {
                "Name": "proxy_type",
                "Type": "T::ProxyType"
              },
              {
                "Name": "delay",
                "Type": "T::BlockNumber"
              },
              {
                "Name": "index",
                "Type": "u16"
              }
            ],
            "Documentation": [
              " Spawn a fresh new account that is guaranteed to be otherwise inaccessible, and",
              " initialize it with a proxy of `proxy_type` for `origin` sender.",
              "",
              " Requires a `Signed` origin.",
              "",
              " - `proxy_type`: The type of the proxy that the sender will be registered as over the",
              " new account. This will almost always be the most permissive `ProxyType` possible to",
              " allow for maximum flexibility.",
              " - `index`: A disambiguation index, in case this is called multiple times in the same",
              " transaction (e.g. with `utility::batch`). Unless you're using `batch` you probably just",
              " want to use `0`.",
              " - `delay`: The announcement period required of the initial proxy. Will generally be",
              " zero.",
              "",
              " Fails with `Duplicate` if this has already been called in this transaction, from the",
              " same sender, with the same parameters.",
              "",
              " Fails if there are insufficient funds to pay for deposit.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of the number of proxies the user has (P).",
              " # \u003c/weight\u003e",
              " TODO: Might be over counting 1 read"
            ]
          },
          {
            "Name": "kill_anonymous",
            "Args": [
              {
                "Name": "spawner",
                "Type": "T::AccountId"
              },
              {
                "Name": "proxy_type",
                "Type": "T::ProxyType"
              },
              {
                "Name": "index",
                "Type": "u16"
              },
              {
                "Name": "height",
                "Type": "Compact\u003cT::BlockNumber\u003e"
              },
              {
                "Name": "ext_index",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Removes a previously spawned anonymous proxy.",
              "",
              " WARNING: **All access to this account will be lost.** Any funds held in it will be",
              " inaccessible.",
              "",
              " Requires a `Signed` origin, and the sender account must have been created by a call to",
              " `anonymous` with corresponding parameters.",
              "",
              " - `spawner`: The account that originally called `anonymous` to create this account.",
              " - `index`: The disambiguation index originally passed to `anonymous`. Probably `0`.",
              " - `proxy_type`: The proxy type originally passed to `anonymous`.",
              " - `height`: The height of the chain when the call to `anonymous` was processed.",
              " - `ext_index`: The extrinsic index in which the call to `anonymous` was processed.",
              "",
              " Fails with `NoPermission` in case the caller is not a previously created anonymous",
              " account whose `anonymous` call has corresponding parameters.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of the number of proxies the user has (P).",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "announce",
            "Args": [
              {
                "Name": "real",
                "Type": "T::AccountId"
              },
              {
                "Name": "call_hash",
                "Type": "CallHashOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Publish the hash of a proxy-call that will be made in the future.",
              "",
              " This must be called some number of blocks before the corresponding `proxy` is attempted",
              " if the delay associated with the proxy relationship is greater than zero.",
              "",
              " No more than `MaxPending` announcements may be made at any one time.",
              "",
              " This will take a deposit of `AnnouncementDepositFactor` as well as",
              " `AnnouncementDepositBase` if there are no other pending announcements.",
              "",
              " The dispatch origin for this call must be _Signed_ and a proxy of `real`.",
              "",
              " Parameters:",
              " - `real`: The account that the proxy will make a call on behalf of.",
              " - `call_hash`: The hash of the call to be made by the `real` account.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of:",
              " - A: the number of announcements made.",
              " - P: the number of proxies the user has.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "remove_announcement",
            "Args": [
              {
                "Name": "real",
                "Type": "T::AccountId"
              },
              {
                "Name": "call_hash",
                "Type": "CallHashOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Remove a given announcement.",
              "",
              " May be called by a proxy account to remove a call they previously announced and return",
              " the deposit.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `real`: The account that the proxy will make a call on behalf of.",
              " - `call_hash`: The hash of the call to be made by the `real` account.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of:",
              " - A: the number of announcements made.",
              " - P: the number of proxies the user has.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "reject_announcement",
            "Args": [
              {
                "Name": "delegate",
                "Type": "T::AccountId"
              },
              {
                "Name": "call_hash",
                "Type": "CallHashOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Remove the given announcement of a delegate.",
              "",
              " May be called by a target (proxied) account to remove a call that one of their delegates",
              " (`delegate`) has announced they want to execute. The deposit is returned.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `delegate`: The account that previously announced the call.",
              " - `call_hash`: The hash of the call to be made.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of:",
              " - A: the number of announcements made.",
              " - P: the number of proxies the user has.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "proxy_announced",
            "Args": [
              {
                "Name": "delegate",
                "Type": "T::AccountId"
              },
              {
                "Name": "real",
                "Type": "T::AccountId"
              },
              {
                "Name": "force_proxy_type",
                "Type": "Option\u003cT::ProxyType\u003e"
              },
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Dispatch the given `call` from an account that the sender is authorized for through",
              " `add_proxy`.",
              "",
              " Removes any corresponding announcement(s).",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " Parameters:",
              " - `real`: The account that the proxy will make a call on behalf of.",
              " - `force_proxy_type`: Specify the exact proxy type to be used and checked for this call.",
              " - `call`: The call to be made by the `real` account.",
              "",
              " # \u003cweight\u003e",
              " Weight is a function of:",
              " - A: the number of announcements made.",
              " - P: the number of proxies the user has.",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "ProxyExecuted",
            "Args": [
              "DispatchResult"
            ],
            "Documentation": [
              " A proxy was executed correctly, with the given \\[result\\]."
            ]
          },
          {
            "Name": "AnonymousCreated",
            "Args": [
              "AccountId",
              "AccountId",
              "ProxyType",
              "u16"
            ],
            "Documentation": [
              " Anonymous account has been created by new proxy with given",
              " disambiguation index and proxy type. \\[anonymous, who, proxy_type, disambiguation_index\\]"
            ]
          },
          {
            "Name": "Announced",
            "Args": [
              "AccountId",
              "AccountId",
              "Hash"
            ],
            "Documentation": [
              " An announcement was placed to make a call in the future. \\[real, proxy, call_hash\\]"
            ]
          }
        ],
        "Constants": [
          {
            "Name": "ProxyDepositBase",
            "Type": "BalanceOf\u003cT\u003e",
            "Value": "AAD5Gnb/4A0AAAAAAAAAAA==",
            "Documentation": [
              " The base amount of currency needed to reserve for creating a proxy.",
              "",
              " This is held for an additional storage item whose value size is",
              " `sizeof(Balance)` bytes and whose key size is `sizeof(AccountId)` bytes."
            ]
          },
          {
            "Name": "ProxyDepositFactor",
            "Type": "BalanceOf\u003cT\u003e",
            "Value": "ACBnb/6+AAAAAAAAAAAAAA==",
            "Documentation": [
              " The amount of currency needed per proxy added.",
              "",
              " This is held for adding 32 bytes plus an instance of `ProxyType` more into a pre-existing",
              " storage value. Thus, when configuring `ProxyDepositFactor` one should take into account",
              " `32 + proxy_type.encode().len()` bytes of data."
            ]
          },
          {
            "Name": "MaxProxies",
            "Type": "u16",
            "Value": "IAA=",
            "Documentation": [
              " The maximum amount of proxies allowed for a single account."
            ]
          },
          {
            "Name": "MaxPending",
            "Type": "u32",
            "Value": "IAAAAA==",
            "Documentation": [
              " The maximum amount of time-delayed announcements that are allowed to be pending."
            ]
          },
          {
            "Name": "AnnouncementDepositBase",
            "Type": "BalanceOf\u003cT\u003e",
            "Value": "AAD5Gnb/4A0AAAAAAAAAAA==",
            "Documentation": [
              " The base amount of currency needed to reserve for creating an announcement.",
              "",
              " This is held when a new storage item holding a `Balance` is created (typically 16 bytes)."
            ]
          },
          {
            "Name": "AnnouncementDepositFactor",
            "Type": "BalanceOf\u003cT\u003e",
            "Value": "AAATKVH9AQAAAAAAAAAAAA==",
            "Documentation": [
              " The amount of currency needed per announcement made.",
              "",
              " This is held for adding an `AccountId`, `Hash` and `BlockNumber` (typically 68 bytes)",
              " into a pre-existing storage value."
            ]
          }
        ],
        "Errors": [
          {
            "Name": "TooMany",
            "Documentation": [
              " There are too many proxies registered or too many announcements pending."
            ]
          },
          {
            "Name": "NotFound",
            "Documentation": [
              " Proxy registration not found."
            ]
          },
          {
            "Name": "NotProxy",
            "Documentation": [
              " Sender is not a proxy of the account to be proxied."
            ]
          },
          {
            "Name": "Unproxyable",
            "Documentation": [
              " A call which is incompatible with the proxy type's filter was attempted."
            ]
          },
          {
            "Name": "Duplicate",
            "Documentation": [
              " Account is already a proxy."
            ]
          },
          {
            "Name": "NoPermission",
            "Documentation": [
              " Call may not be made by proxy because it may escalate its privileges."
            ]
          },
          {
            "Name": "Unannounced",
            "Documentation": [
              " Announcement, if made at all, was made too recently."
            ]
          },
          {
            "Name": "NoSelfProxy",
            "Documentation": [
              " Cannot add self as proxy."
            ]
          }
        ],
        "Index": 31
      },
      {
        "Name": "Sudo",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Sudo",
          "Items": [
            {
              "Name": "Key",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::AccountId",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAA=",
              "Documentation": [
                " The `AccountId` of the sudo key."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "sudo",
            "Args": [
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Authenticates the sudo key and dispatches a function call with `Root` origin.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " # \u003cweight\u003e",
              " - O(1).",
              " - Limited storage reads.",
              " - One DB write (event).",
              " - Weight of derivative `call` execution + 10,000.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "sudo_unchecked_weight",
            "Args": [
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              },
              {
                "Name": "_weight",
                "Type": "Weight"
              }
            ],
            "Documentation": [
              " Authenticates the sudo key and dispatches a function call with `Root` origin.",
              " This function does not check the weight of the call, and instead allows the",
              " Sudo user to specify the weight of the call.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " # \u003cweight\u003e",
              " - O(1).",
              " - The weight of this call is defined by the caller.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "set_key",
            "Args": [
              {
                "Name": "new",
                "Type": "\u003cT::Lookup as StaticLookup\u003e::Source"
              }
            ],
            "Documentation": [
              " Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " # \u003cweight\u003e",
              " - O(1).",
              " - Limited storage reads.",
              " - One DB change.",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "sudo_as",
            "Args": [
              {
                "Name": "who",
                "Type": "\u003cT::Lookup as StaticLookup\u003e::Source"
              },
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Authenticates the sudo key and dispatches a function call with `Signed` origin from",
              " a given account.",
              "",
              " The dispatch origin for this call must be _Signed_.",
              "",
              " # \u003cweight\u003e",
              " - O(1).",
              " - Limited storage reads.",
              " - One DB write (event).",
              " - Weight of derivative `call` execution + 10,000.",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Sudid",
            "Args": [
              "DispatchResult"
            ],
            "Documentation": [
              " A sudo just took place. \\[result\\]"
            ]
          },
          {
            "Name": "KeyChanged",
            "Args": [
              "AccountId"
            ],
            "Documentation": [
              " The \\[sudoer\\] just switched identity; the old key is supplied."
            ]
          },
          {
            "Name": "SudoAsDone",
            "Args": [
              "DispatchResult"
            ],
            "Documentation": [
              " A sudo just took place. \\[result\\]"
            ]
          }
        ],
        "Constants": null,
        "Errors": [
          {
            "Name": "RequireSudo",
            "Documentation": [
              " Sender must be the Sudo account"
            ]
          }
        ],
        "Index": 40
      },
      {
        "Name": "EthereumChainId",
        "HasStorage": true,
        "Storage": {
          "Prefix": "EthereumChainId",
          "Items": [
            {
              "Name": "ChainId",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u64",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAA=",
              "Documentation": null
            }
          ]
        },
        "HasCalls": false,
        "Calls": null,
        "HasEvents": false,
        "Events": null,
        "Constants": null,
        "Errors": null,
        "Index": 50
      },
      {
        "Name": "EVM",
        "HasStorage": true,
        "Storage": {
          "Prefix": "EVM",
          "Items": [
            {
              "Name": "AccountCodes",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "H160",
                  "Value": "Vec\u003cu8\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": null
            },
            {
              "Name": "AccountStorages",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": true,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "H160",
                  "Key2": "H256",
                  "Value": "H256",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
              "Documentation": null
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "withdraw",
            "Args": [
              {
                "Name": "address",
                "Type": "H160"
              },
              {
                "Name": "value",
                "Type": "BalanceOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Withdraw balance from EVM into currency/balances pallet."
            ]
          },
          {
            "Name": "call",
            "Args": [
              {
                "Name": "source",
                "Type": "H160"
              },
              {
                "Name": "target",
                "Type": "H160"
              },
              {
                "Name": "input",
                "Type": "Vec\u003cu8\u003e"
              },
              {
                "Name": "value",
                "Type": "U256"
              },
              {
                "Name": "gas_limit",
                "Type": "u64"
              },
              {
                "Name": "gas_price",
                "Type": "U256"
              },
              {
                "Name": "nonce",
                "Type": "Option\u003cU256\u003e"
              }
            ],
            "Documentation": [
              " Issue an EVM call operation. This is similar to a message call transaction in Ethereum."
            ]
          },
          {
            "Name": "create",
            "Args": [
              {
                "Name": "source",
                "Type": "H160"
              },
              {
                "Name": "init",
                "Type": "Vec\u003cu8\u003e"
              },
              {
                "Name": "value",
                "Type": "U256"
              },
              {
                "Name": "gas_limit",
                "Type": "u64"
              },
              {
                "Name": "gas_price",
                "Type": "U256"
              },
              {
                "Name": "nonce",
                "Type": "Option\u003cU256\u003e"
              }
            ],
            "Documentation": [
              " Issue an EVM create operation. This is similar to a contract creation transaction in",
              " Ethereum."
            ]
          },
          {
            "Name": "create2",
            "Args": [
              {
                "Name": "source",
                "Type": "H160"
              },
              {
                "Name": "init",
                "Type": "Vec\u003cu8\u003e"
              },
              {
                "Name": "salt",
                "Type": "H256"
              },
              {
                "Name": "value",
                "Type": "U256"
              },
              {
                "Name": "gas_limit",
                "Type": "u64"
              },
              {
                "Name": "gas_price",
                "Type": "U256"
              },
              {
                "Name": "nonce",
                "Type": "Option\u003cU256\u003e"
              }
            ],
            "Documentation": [
              " Issue an EVM create2 operation."
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Log",
            "Args": [
              "Log"
            ],
            "Documentation": [
              " Ethereum events from contracts."
            ]
          },
          {
            "Name": "Created",
            "Args": [
              "H160"
            ],
            "Documentation": [
              " A contract has been created at given \\[address\\]."
            ]
          },
          {
            "Name": "CreatedFailed",
            "Args": [
              "H160"
            ],
            "Documentation": [
              " A \\[contract\\] was attempted to be created, but the execution failed."
            ]
          },
          {
            "Name": "Executed",
            "Args": [
              "H160"
            ],
            "Documentation": [
              " A \\[contract\\] has been executed successfully with states applied."
            ]
          },
          {
            "Name": "ExecutedFailed",
            "Args": [
              "H160"
            ],
            "Documentation": [
              " A \\[contract\\] has been executed with errors. States are reverted with only gas fees applied."
            ]
          },
          {
            "Name": "BalanceDeposit",
            "Args": [
              "AccountId",
              "H160",
              "U256"
            ],
            "Documentation": [
              " A deposit has been made at a given address. \\[sender, address, value\\]"
            ]
          },
          {
            "Name": "BalanceWithdraw",
            "Args": [
              "AccountId",
              "H160",
              "U256"
            ],
            "Documentation": [
              " A withdrawal has been made from a given address. \\[sender, address, value\\]"
            ]
          }
        ],
        "Constants": null,
        "Errors": [
          {
            "Name": "BalanceLow",
            "Documentation": [
              " Not enough balance to perform action"
            ]
          },
          {
            "Name": "FeeOverflow",
            "Documentation": [
              " Calculating total fee overflowed"
            ]
          },
          {
            "Name": "PaymentOverflow",
            "Documentation": [
              " Calculating total payment overflowed"
            ]
          },
          {
            "Name": "WithdrawFailed",
            "Documentation": [
              " Withdraw fee failed"
            ]
          },
          {
            "Name": "GasPriceTooLow",
            "Documentation": [
              " Gas price is too low."
            ]
          },
          {
            "Name": "InvalidNonce",
            "Documentation": [
              " Nonce is invalid"
            ]
          }
        ],
        "Index": 51
      },
      {
        "Name": "Ethereum",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Ethereum",
          "Items": [
            {
              "Name": "Pending",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003c(ethereum::Transaction, TransactionStatus, ethereum::Receipt)\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Current building block's transactions and receipts."
              ]
            },
            {
              "Name": "CurrentBlock",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "ethereum::Block",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The current Ethereum block."
              ]
            },
            {
              "Name": "CurrentReceipts",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cethereum::Receipt\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The current Ethereum receipts."
              ]
            },
            {
              "Name": "CurrentTransactionStatuses",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cTransactionStatus\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The current transaction statuses."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "transact",
            "Args": [
              {
                "Name": "transaction",
                "Type": "ethereum::Transaction"
              }
            ],
            "Documentation": [
              " Transact an Ethereum transaction."
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Executed",
            "Args": [
              "H160",
              "H160",
              "H256",
              "ExitReason"
            ],
            "Documentation": [
              " An ethereum transaction was successfully executed. [from, to/contract_address, transaction_hash, exit_reason]"
            ]
          }
        ],
        "Constants": null,
        "Errors": null,
        "Index": 52
      },
      {
        "Name": "Scheduler",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Scheduler",
          "Items": [
            {
              "Name": "Agenda",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::BlockNumber",
                  "Value": "Vec\u003cOption\u003cScheduled\u003c\u003cT as Config\u003e::Call, T::BlockNumber, T::\nPalletsOrigin, T::AccountId\u003e\u003e\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Items to be executed, indexed by the block number that they should be executed on."
              ]
            },
            {
              "Name": "Lookup",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "Vec\u003cu8\u003e",
                  "Value": "TaskAddress\u003cT::BlockNumber\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Lookup from identity to the block number and index of the task."
              ]
            },
            {
              "Name": "StorageVersion",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Releases",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Storage version of the pallet.",
                "",
                " New networks start with last version."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "schedule",
            "Args": [
              {
                "Name": "when",
                "Type": "T::BlockNumber"
              },
              {
                "Name": "maybe_periodic",
                "Type": "Option\u003cschedule::Period\u003cT::BlockNumber\u003e\u003e"
              },
              {
                "Name": "priority",
                "Type": "schedule::Priority"
              },
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Anonymously schedule a task.",
              "",
              " # \u003cweight\u003e",
              " - S = Number of already scheduled calls",
              " - Base Weight: 22.29 + .126 * S µs",
              " - DB Weight:",
              "     - Read: Agenda",
              "     - Write: Agenda",
              " - Will use base weight of 25 which should be good for up to 30 scheduled calls",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "cancel",
            "Args": [
              {
                "Name": "when",
                "Type": "T::BlockNumber"
              },
              {
                "Name": "index",
                "Type": "u32"
              }
            ],
            "Documentation": [
              " Cancel an anonymously scheduled task.",
              "",
              " # \u003cweight\u003e",
              " - S = Number of already scheduled calls",
              " - Base Weight: 22.15 + 2.869 * S µs",
              " - DB Weight:",
              "     - Read: Agenda",
              "     - Write: Agenda, Lookup",
              " - Will use base weight of 100 which should be good for up to 30 scheduled calls",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "schedule_named",
            "Args": [
              {
                "Name": "id",
                "Type": "Vec\u003cu8\u003e"
              },
              {
                "Name": "when",
                "Type": "T::BlockNumber"
              },
              {
                "Name": "maybe_periodic",
                "Type": "Option\u003cschedule::Period\u003cT::BlockNumber\u003e\u003e"
              },
              {
                "Name": "priority",
                "Type": "schedule::Priority"
              },
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Schedule a named task.",
              "",
              " # \u003cweight\u003e",
              " - S = Number of already scheduled calls",
              " - Base Weight: 29.6 + .159 * S µs",
              " - DB Weight:",
              "     - Read: Agenda, Lookup",
              "     - Write: Agenda, Lookup",
              " - Will use base weight of 35 which should be good for more than 30 scheduled calls",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "cancel_named",
            "Args": [
              {
                "Name": "id",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Cancel a named scheduled task.",
              "",
              " # \u003cweight\u003e",
              " - S = Number of already scheduled calls",
              " - Base Weight: 24.91 + 2.907 * S µs",
              " - DB Weight:",
              "     - Read: Agenda, Lookup",
              "     - Write: Agenda, Lookup",
              " - Will use base weight of 100 which should be good for up to 30 scheduled calls",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "schedule_after",
            "Args": [
              {
                "Name": "after",
                "Type": "T::BlockNumber"
              },
              {
                "Name": "maybe_periodic",
                "Type": "Option\u003cschedule::Period\u003cT::BlockNumber\u003e\u003e"
              },
              {
                "Name": "priority",
                "Type": "schedule::Priority"
              },
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Anonymously schedule a task after a delay.",
              "",
              " # \u003cweight\u003e",
              " Same as [`schedule`].",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "schedule_named_after",
            "Args": [
              {
                "Name": "id",
                "Type": "Vec\u003cu8\u003e"
              },
              {
                "Name": "after",
                "Type": "T::BlockNumber"
              },
              {
                "Name": "maybe_periodic",
                "Type": "Option\u003cschedule::Period\u003cT::BlockNumber\u003e\u003e"
              },
              {
                "Name": "priority",
                "Type": "schedule::Priority"
              },
              {
                "Name": "call",
                "Type": "Box\u003c\u003cT as Config\u003e::Call\u003e"
              }
            ],
            "Documentation": [
              " Schedule a named task after a delay.",
              "",
              " # \u003cweight\u003e",
              " Same as [`schedule_named`].",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Scheduled",
            "Args": [
              "BlockNumber",
              "u32"
            ],
            "Documentation": [
              " Scheduled some task. \\[when, index\\]"
            ]
          },
          {
            "Name": "Canceled",
            "Args": [
              "BlockNumber",
              "u32"
            ],
            "Documentation": [
              " Canceled some task. \\[when, index\\]"
            ]
          },
          {
            "Name": "Dispatched",
            "Args": [
              "TaskAddress\u003cBlockNumber\u003e",
              "Option\u003cVec\u003cu8\u003e\u003e",
              "DispatchResult"
            ],
            "Documentation": [
              " Dispatched some task. \\[task, id, result\\]"
            ]
          }
        ],
        "Constants": null,
        "Errors": [
          {
            "Name": "FailedToSchedule",
            "Documentation": [
              " Failed to schedule a call"
            ]
          },
          {
            "Name": "NotFound",
            "Documentation": [
              " Cannot find the scheduled call."
            ]
          },
          {
            "Name": "TargetBlockNumberInPast",
            "Documentation": [
              " Given target block number is in the past."
            ]
          },
          {
            "Name": "RescheduleNoChange",
            "Documentation": [
              " Reschedule failed because it does not change scheduled time."
            ]
          }
        ],
        "Index": 60
      },
      {
        "Name": "Democracy",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Democracy",
          "Items": [
            {
              "Name": "PublicPropCount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "PropIndex",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " The number of (public) proposals that have been made so far."
              ]
            },
            {
              "Name": "PublicProps",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003c(PropIndex, T::Hash, T::AccountId)\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The public proposals. Unsorted. The second item is the proposal's hash."
              ]
            },
            {
              "Name": "DepositOf",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "PropIndex",
                  "Value": "(Vec\u003cT::AccountId\u003e, BalanceOf\u003cT\u003e)",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Those who have locked a deposit.",
                "",
                " TWOX-NOTE: Safe, as increasing integer keys are safe."
              ]
            },
            {
              "Name": "Preimages",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": true
                  },
                  "Key": "T::Hash",
                  "Value": "PreimageStatus\u003cT::AccountId, BalanceOf\u003cT\u003e, T::BlockNumber\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Map of hashes to the proposal preimage, along with who registered it and their deposit.",
                " The block number is the block at which it was deposited."
              ]
            },
            {
              "Name": "ReferendumCount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "ReferendumIndex",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " The next free referendum index, aka the number of referenda started so far."
              ]
            },
            {
              "Name": "LowestUnbaked",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "ReferendumIndex",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " The lowest referendum index representing an unbaked referendum. Equal to",
                " `ReferendumCount` if there isn't a unbaked referendum."
              ]
            },
            {
              "Name": "ReferendumInfoOf",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "ReferendumIndex",
                  "Value": "ReferendumInfo\u003cT::BlockNumber, T::Hash, BalanceOf\u003cT\u003e\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Information concerning any given referendum.",
                "",
                " TWOX-NOTE: SAFE as indexes are not under an attacker’s control."
              ]
            },
            {
              "Name": "VotingOf",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "Voting\u003cBalanceOf\u003cT\u003e, T::AccountId, T::BlockNumber\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
              "Documentation": [
                " All votes for a particular voter. We store the balance for the number of votes that we",
                " have recorded. The second item is the total amount of delegations, that will be added.",
                "",
                " TWOX-NOTE: SAFE as `AccountId`s are crypto hashes anyway."
              ]
            },
            {
              "Name": "Locks",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "T::AccountId",
                  "Value": "T::BlockNumber",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Accounts for which there are locks in action which may be removed at some point in the",
                " future. The value is the block number at which the lock expires and may be removed.",
                "",
                " TWOX-NOTE: OK ― `AccountId` is a secure hash."
              ]
            },
            {
              "Name": "LastTabledWasExternal",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "bool",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " True if the last referendum tabled was submitted externally. False if it was a public",
                " proposal."
              ]
            },
            {
              "Name": "NextExternal",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "(T::Hash, VoteThreshold)",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The referendum to be tabled whenever it would be valid to table an external proposal.",
                " This happens when a referendum needs to be tabled and one of two conditions are met:",
                " - `LastTabledWasExternal` is `false`; or",
                " - `PublicProps` is empty."
              ]
            },
            {
              "Name": "Blacklist",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": true
                  },
                  "Key": "T::Hash",
                  "Value": "(T::BlockNumber, Vec\u003cT::AccountId\u003e)",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " A record of who vetoed what. Maps proposal hash to a possible existent block number",
                " (until when it may not be resubmitted) and who vetoed it."
              ]
            },
            {
              "Name": "Cancellations",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": true
                  },
                  "Key": "T::Hash",
                  "Value": "bool",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Record of all proposals that have been subject to emergency cancellation."
              ]
            },
            {
              "Name": "StorageVersion",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Releases",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Storage version of the pallet.",
                "",
                " New networks start with last version."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "propose",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              },
              {
                "Name": "value",
                "Type": "Compact\u003cBalanceOf\u003cT\u003e\u003e"
              }
            ],
            "Documentation": [
              " Propose a sensitive action to be taken.",
              "",
              " The dispatch origin of this call must be _Signed_ and the sender must",
              " have funds to cover the deposit.",
              "",
              " - `proposal_hash`: The hash of the proposal preimage.",
              " - `value`: The amount of deposit (must be at least `MinimumDeposit`).",
              "",
              " Emits `Proposed`.",
              "",
              " Weight: `O(p)`"
            ]
          },
          {
            "Name": "second",
            "Args": [
              {
                "Name": "proposal",
                "Type": "Compact\u003cPropIndex\u003e"
              },
              {
                "Name": "seconds_upper_bound",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Signals agreement with a particular proposal.",
              "",
              " The dispatch origin of this call must be _Signed_ and the sender",
              " must have funds to cover the deposit, equal to the original deposit.",
              "",
              " - `proposal`: The index of the proposal to second.",
              " - `seconds_upper_bound`: an upper bound on the current number of seconds on this",
              "   proposal. Extrinsic is weighted according to this value with no refund.",
              "",
              " Weight: `O(S)` where S is the number of seconds a proposal already has."
            ]
          },
          {
            "Name": "vote",
            "Args": [
              {
                "Name": "ref_index",
                "Type": "Compact\u003cReferendumIndex\u003e"
              },
              {
                "Name": "vote",
                "Type": "AccountVote\u003cBalanceOf\u003cT\u003e\u003e"
              }
            ],
            "Documentation": [
              " Vote in a referendum. If `vote.is_aye()`, the vote is to enact the proposal;",
              " otherwise it is a vote to keep the status quo.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `ref_index`: The index of the referendum to vote for.",
              " - `vote`: The vote configuration.",
              "",
              " Weight: `O(R)` where R is the number of referendums the voter has voted on."
            ]
          },
          {
            "Name": "emergency_cancel",
            "Args": [
              {
                "Name": "ref_index",
                "Type": "ReferendumIndex"
              }
            ],
            "Documentation": [
              " Schedule an emergency cancellation of a referendum. Cannot happen twice to the same",
              " referendum.",
              "",
              " The dispatch origin of this call must be `CancellationOrigin`.",
              "",
              " -`ref_index`: The index of the referendum to cancel.",
              "",
              " Weight: `O(1)`."
            ]
          },
          {
            "Name": "external_propose",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              }
            ],
            "Documentation": [
              " Schedule a referendum to be tabled once it is legal to schedule an external",
              " referendum.",
              "",
              " The dispatch origin of this call must be `ExternalOrigin`.",
              "",
              " - `proposal_hash`: The preimage hash of the proposal.",
              "",
              " Weight: `O(V)` with V number of vetoers in the blacklist of proposal.",
              "   Decoding vec of length V. Charged as maximum"
            ]
          },
          {
            "Name": "external_propose_majority",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              }
            ],
            "Documentation": [
              " Schedule a majority-carries referendum to be tabled next once it is legal to schedule",
              " an external referendum.",
              "",
              " The dispatch of this call must be `ExternalMajorityOrigin`.",
              "",
              " - `proposal_hash`: The preimage hash of the proposal.",
              "",
              " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
              " pre-scheduled `external_propose` call.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "Name": "external_propose_default",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              }
            ],
            "Documentation": [
              " Schedule a negative-turnout-bias referendum to be tabled next once it is legal to",
              " schedule an external referendum.",
              "",
              " The dispatch of this call must be `ExternalDefaultOrigin`.",
              "",
              " - `proposal_hash`: The preimage hash of the proposal.",
              "",
              " Unlike `external_propose`, blacklisting has no effect on this and it may replace a",
              " pre-scheduled `external_propose` call.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "Name": "fast_track",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              },
              {
                "Name": "voting_period",
                "Type": "T::BlockNumber"
              },
              {
                "Name": "delay",
                "Type": "T::BlockNumber"
              }
            ],
            "Documentation": [
              " Schedule the currently externally-proposed majority-carries referendum to be tabled",
              " immediately. If there is no externally-proposed referendum currently, or if there is one",
              " but it is not a majority-carries referendum then it fails.",
              "",
              " The dispatch of this call must be `FastTrackOrigin`.",
              "",
              " - `proposal_hash`: The hash of the current external proposal.",
              " - `voting_period`: The period that is allowed for voting on this proposal. Increased to",
              "   `FastTrackVotingPeriod` if too low.",
              " - `delay`: The number of block after voting has ended in approval and this should be",
              "   enacted. This doesn't have a minimum amount.",
              "",
              " Emits `Started`.",
              "",
              " Weight: `O(1)`"
            ]
          },
          {
            "Name": "veto_external",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              }
            ],
            "Documentation": [
              " Veto and blacklist the external proposal hash.",
              "",
              " The dispatch origin of this call must be `VetoOrigin`.",
              "",
              " - `proposal_hash`: The preimage hash of the proposal to veto and blacklist.",
              "",
              " Emits `Vetoed`.",
              "",
              " Weight: `O(V + log(V))` where V is number of `existing vetoers`"
            ]
          },
          {
            "Name": "cancel_referendum",
            "Args": [
              {
                "Name": "ref_index",
                "Type": "Compact\u003cReferendumIndex\u003e"
              }
            ],
            "Documentation": [
              " Remove a referendum.",
              "",
              " The dispatch origin of this call must be _Root_.",
              "",
              " - `ref_index`: The index of the referendum to cancel.",
              "",
              " # Weight: `O(1)`."
            ]
          },
          {
            "Name": "cancel_queued",
            "Args": [
              {
                "Name": "which",
                "Type": "ReferendumIndex"
              }
            ],
            "Documentation": [
              " Cancel a proposal queued for enactment.",
              "",
              " The dispatch origin of this call must be _Root_.",
              "",
              " - `which`: The index of the referendum to cancel.",
              "",
              " Weight: `O(D)` where `D` is the items in the dispatch queue. Weighted as `D = 10`."
            ]
          },
          {
            "Name": "delegate",
            "Args": [
              {
                "Name": "to",
                "Type": "T::AccountId"
              },
              {
                "Name": "conviction",
                "Type": "Conviction"
              },
              {
                "Name": "balance",
                "Type": "BalanceOf\u003cT\u003e"
              }
            ],
            "Documentation": [
              " Delegate the voting power (with some given conviction) of the sending account.",
              "",
              " The balance delegated is locked for as long as it's delegated, and thereafter for the",
              " time appropriate for the conviction's lock period.",
              "",
              " The dispatch origin of this call must be _Signed_, and the signing account must either:",
              "   - be delegating already; or",
              "   - have no voting activity (if there is, then it will need to be removed/consolidated",
              "     through `reap_vote` or `unvote`).",
              "",
              " - `to`: The account whose voting the `target` account's voting power will follow.",
              " - `conviction`: The conviction that will be attached to the delegated votes. When the",
              "   account is undelegated, the funds will be locked for the corresponding period.",
              " - `balance`: The amount of the account's balance to be used in delegating. This must",
              "   not be more than the account's current balance.",
              "",
              " Emits `Delegated`.",
              "",
              " Weight: `O(R)` where R is the number of referendums the voter delegating to has",
              "   voted on. Weight is charged as if maximum votes."
            ]
          },
          {
            "Name": "undelegate",
            "Args": null,
            "Documentation": [
              " Undelegate the voting power of the sending account.",
              "",
              " Tokens may be unlocked following once an amount of time consistent with the lock period",
              " of the conviction with which the delegation was issued.",
              "",
              " The dispatch origin of this call must be _Signed_ and the signing account must be",
              " currently delegating.",
              "",
              " Emits `Undelegated`.",
              "",
              " Weight: `O(R)` where R is the number of referendums the voter delegating to has",
              "   voted on. Weight is charged as if maximum votes."
            ]
          },
          {
            "Name": "clear_public_proposals",
            "Args": null,
            "Documentation": [
              " Clears all public proposals.",
              "",
              " The dispatch origin of this call must be _Root_.",
              "",
              " Weight: `O(1)`."
            ]
          },
          {
            "Name": "note_preimage",
            "Args": [
              {
                "Name": "encoded_proposal",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Register the preimage for an upcoming proposal. This doesn't require the proposal to be",
              " in the dispatch queue but does require a deposit, returned once enacted.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `encoded_proposal`: The preimage of a proposal.",
              "",
              " Emits `PreimageNoted`.",
              "",
              " Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."
            ]
          },
          {
            "Name": "note_preimage_operational",
            "Args": [
              {
                "Name": "encoded_proposal",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Same as `note_preimage` but origin is `OperationalPreimageOrigin`."
            ]
          },
          {
            "Name": "note_imminent_preimage",
            "Args": [
              {
                "Name": "encoded_proposal",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Register the preimage for an upcoming proposal. This requires the proposal to be",
              " in the dispatch queue. No deposit is needed. When this call is successful, i.e.",
              " the preimage has not been uploaded before and matches some imminent proposal,",
              " no fee is paid.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `encoded_proposal`: The preimage of a proposal.",
              "",
              " Emits `PreimageNoted`.",
              "",
              " Weight: `O(E)` with E size of `encoded_proposal` (protected by a required deposit)."
            ]
          },
          {
            "Name": "note_imminent_preimage_operational",
            "Args": [
              {
                "Name": "encoded_proposal",
                "Type": "Vec\u003cu8\u003e"
              }
            ],
            "Documentation": [
              " Same as `note_imminent_preimage` but origin is `OperationalPreimageOrigin`."
            ]
          },
          {
            "Name": "reap_preimage",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              },
              {
                "Name": "proposal_len_upper_bound",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Remove an expired proposal preimage and collect the deposit.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `proposal_hash`: The preimage hash of a proposal.",
              " - `proposal_length_upper_bound`: an upper bound on length of the proposal.",
              "   Extrinsic is weighted according to this value with no refund.",
              "",
              " This will only work after `VotingPeriod` blocks from the time that the preimage was",
              " noted, if it's the same account doing it. If it's a different account, then it'll only",
              " work an additional `EnactmentPeriod` later.",
              "",
              " Emits `PreimageReaped`.",
              "",
              " Weight: `O(D)` where D is length of proposal."
            ]
          },
          {
            "Name": "unlock",
            "Args": [
              {
                "Name": "target",
                "Type": "T::AccountId"
              }
            ],
            "Documentation": [
              " Unlock tokens that have an expired lock.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `target`: The account to remove the lock on.",
              "",
              " Weight: `O(R)` with R number of vote of target."
            ]
          },
          {
            "Name": "remove_vote",
            "Args": [
              {
                "Name": "index",
                "Type": "ReferendumIndex"
              }
            ],
            "Documentation": [
              " Remove a vote for a referendum.",
              "",
              " If:",
              " - the referendum was cancelled, or",
              " - the referendum is ongoing, or",
              " - the referendum has ended such that",
              "   - the vote of the account was in opposition to the result; or",
              "   - there was no conviction to the account's vote; or",
              "   - the account made a split vote",
              " ...then the vote is removed cleanly and a following call to `unlock` may result in more",
              " funds being available.",
              "",
              " If, however, the referendum has ended and:",
              " - it finished corresponding to the vote of the account, and",
              " - the account made a standard vote with conviction, and",
              " - the lock period of the conviction is not over",
              " ...then the lock will be aggregated into the overall account's lock, which may involve",
              " *overlocking* (where the two locks are combined into a single lock that is the maximum",
              " of both the amount locked and the time is it locked for).",
              "",
              " The dispatch origin of this call must be _Signed_, and the signer must have a vote",
              " registered for referendum `index`.",
              "",
              " - `index`: The index of referendum of the vote to be removed.",
              "",
              " Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.",
              "   Weight is calculated for the maximum number of vote."
            ]
          },
          {
            "Name": "remove_other_vote",
            "Args": [
              {
                "Name": "target",
                "Type": "T::AccountId"
              },
              {
                "Name": "index",
                "Type": "ReferendumIndex"
              }
            ],
            "Documentation": [
              " Remove a vote for a referendum.",
              "",
              " If the `target` is equal to the signer, then this function is exactly equivalent to",
              " `remove_vote`. If not equal to the signer, then the vote must have expired,",
              " either because the referendum was cancelled, because the voter lost the referendum or",
              " because the conviction period is over.",
              "",
              " The dispatch origin of this call must be _Signed_.",
              "",
              " - `target`: The account of the vote to be removed; this account must have voted for",
              "   referendum `index`.",
              " - `index`: The index of referendum of the vote to be removed.",
              "",
              " Weight: `O(R + log R)` where R is the number of referenda that `target` has voted on.",
              "   Weight is calculated for the maximum number of vote."
            ]
          },
          {
            "Name": "enact_proposal",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              },
              {
                "Name": "index",
                "Type": "ReferendumIndex"
              }
            ],
            "Documentation": [
              " Enact a proposal from a referendum. For now we just make the weight be the maximum."
            ]
          },
          {
            "Name": "blacklist",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              },
              {
                "Name": "maybe_ref_index",
                "Type": "Option\u003cReferendumIndex\u003e"
              }
            ],
            "Documentation": [
              " Permanently place a proposal into the blacklist. This prevents it from ever being",
              " proposed again.",
              "",
              " If called on a queued public or external proposal, then this will result in it being",
              " removed. If the `ref_index` supplied is an active referendum with the proposal hash,",
              " then it will be cancelled.",
              "",
              " The dispatch origin of this call must be `BlacklistOrigin`.",
              "",
              " - `proposal_hash`: The proposal hash to blacklist permanently.",
              " - `ref_index`: An ongoing referendum whose hash is `proposal_hash`, which will be",
              " cancelled.",
              "",
              " Weight: `O(p)` (though as this is an high-privilege dispatch, we assume it has a",
              "   reasonable value)."
            ]
          },
          {
            "Name": "cancel_proposal",
            "Args": [
              {
                "Name": "prop_index",
                "Type": "Compact\u003cPropIndex\u003e"
              }
            ],
            "Documentation": [
              " Remove a proposal.",
              "",
              " The dispatch origin of this call must be `CancelProposalOrigin`.",
              "",
              " - `prop_index`: The index of the proposal to cancel.",
              "",
              " Weight: `O(p)` where `p = PublicProps::\u003cT\u003e::decode_len()`"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Proposed",
            "Args": [
              "PropIndex",
              "Balance"
            ],
            "Documentation": [
              " A motion has been proposed by a public account. \\[proposal_index, deposit\\]"
            ]
          },
          {
            "Name": "Tabled",
            "Args": [
              "PropIndex",
              "Balance",
              "Vec\u003cAccountId\u003e"
            ],
            "Documentation": [
              " A public proposal has been tabled for referendum vote. \\[proposal_index, deposit, depositors\\]"
            ]
          },
          {
            "Name": "ExternalTabled",
            "Args": null,
            "Documentation": [
              " An external proposal has been tabled."
            ]
          },
          {
            "Name": "Started",
            "Args": [
              "ReferendumIndex",
              "VoteThreshold"
            ],
            "Documentation": [
              " A referendum has begun. \\[ref_index, threshold\\]"
            ]
          },
          {
            "Name": "Passed",
            "Args": [
              "ReferendumIndex"
            ],
            "Documentation": [
              " A proposal has been approved by referendum. \\[ref_index\\]"
            ]
          },
          {
            "Name": "NotPassed",
            "Args": [
              "ReferendumIndex"
            ],
            "Documentation": [
              " A proposal has been rejected by referendum. \\[ref_index\\]"
            ]
          },
          {
            "Name": "Cancelled",
            "Args": [
              "ReferendumIndex"
            ],
            "Documentation": [
              " A referendum has been cancelled. \\[ref_index\\]"
            ]
          },
          {
            "Name": "Executed",
            "Args": [
              "ReferendumIndex",
              "bool"
            ],
            "Documentation": [
              " A proposal has been enacted. \\[ref_index, is_ok\\]"
            ]
          },
          {
            "Name": "Delegated",
            "Args": [
              "AccountId",
              "AccountId"
            ],
            "Documentation": [
              " An account has delegated their vote to another account. \\[who, target\\]"
            ]
          },
          {
            "Name": "Undelegated",
            "Args": [
              "AccountId"
            ],
            "Documentation": [
              " An \\[account\\] has cancelled a previous delegation operation."
            ]
          },
          {
            "Name": "Vetoed",
            "Args": [
              "AccountId",
              "Hash",
              "BlockNumber"
            ],
            "Documentation": [
              " An external proposal has been vetoed. \\[who, proposal_hash, until\\]"
            ]
          },
          {
            "Name": "PreimageNoted",
            "Args": [
              "Hash",
              "AccountId",
              "Balance"
            ],
            "Documentation": [
              " A proposal's preimage was noted, and the deposit taken. \\[proposal_hash, who, deposit\\]"
            ]
          },
          {
            "Name": "PreimageUsed",
            "Args": [
              "Hash",
              "AccountId",
              "Balance"
            ],
            "Documentation": [
              " A proposal preimage was removed and used (the deposit was returned).",
              " \\[proposal_hash, provider, deposit\\]"
            ]
          },
          {
            "Name": "PreimageInvalid",
            "Args": [
              "Hash",
              "ReferendumIndex"
            ],
            "Documentation": [
              " A proposal could not be executed because its preimage was invalid.",
              " \\[proposal_hash, ref_index\\]"
            ]
          },
          {
            "Name": "PreimageMissing",
            "Args": [
              "Hash",
              "ReferendumIndex"
            ],
            "Documentation": [
              " A proposal could not be executed because its preimage was missing.",
              " \\[proposal_hash, ref_index\\]"
            ]
          },
          {
            "Name": "PreimageReaped",
            "Args": [
              "Hash",
              "AccountId",
              "Balance",
              "AccountId"
            ],
            "Documentation": [
              " A registered preimage was removed and the deposit collected by the reaper.",
              " \\[proposal_hash, provider, deposit, reaper\\]"
            ]
          },
          {
            "Name": "Unlocked",
            "Args": [
              "AccountId"
            ],
            "Documentation": [
              " An \\[account\\] has been unlocked successfully."
            ]
          },
          {
            "Name": "Blacklisted",
            "Args": [
              "Hash"
            ],
            "Documentation": [
              " A proposal \\[hash\\] has been blacklisted permanently."
            ]
          }
        ],
        "Constants": [
          {
            "Name": "EnactmentPeriod",
            "Type": "T::BlockNumber",
            "Value": "IBwAAA==",
            "Documentation": [
              " The minimum period of locking and the period between a proposal being approved and enacted.",
              "",
              " It should generally be a little more than the unstake period to ensure that",
              " voting stakers have an opportunity to remove themselves from the system in the case where",
              " they are on the losing side of a vote."
            ]
          },
          {
            "Name": "LaunchPeriod",
            "Type": "T::BlockNumber",
            "Value": "IBwAAA==",
            "Documentation": [
              " How often (in blocks) new public referenda are launched."
            ]
          },
          {
            "Name": "VotingPeriod",
            "Type": "T::BlockNumber",
            "Value": "oIwAAA==",
            "Documentation": [
              " How often (in blocks) to check for new votes."
            ]
          },
          {
            "Name": "MinimumDeposit",
            "Type": "BalanceOf\u003cT\u003e",
            "Value": "AACQnc7agjcAAAAAAAAAAA==",
            "Documentation": [
              " The minimum amount to be used as a deposit for a public referendum proposal."
            ]
          },
          {
            "Name": "FastTrackVotingPeriod",
            "Type": "T::BlockNumber",
            "Value": "IBwAAA==",
            "Documentation": [
              " Minimum voting period allowed for an emergency referendum."
            ]
          },
          {
            "Name": "CooloffPeriod",
            "Type": "T::BlockNumber",
            "Value": "4MQAAA==",
            "Documentation": [
              " Period in blocks where an external proposal may not be re-submitted after being vetoed."
            ]
          },
          {
            "Name": "PreimageByteDeposit",
            "Type": "BalanceOf\u003cT\u003e",
            "Value": "AKByThgJAAAAAAAAAAAAAA==",
            "Documentation": [
              " The amount of balance that must be deposited per byte of preimage stored."
            ]
          },
          {
            "Name": "MaxVotes",
            "Type": "u32",
            "Value": "ZAAAAA==",
            "Documentation": [
              " The maximum number of votes for an account."
            ]
          }
        ],
        "Errors": [
          {
            "Name": "ValueLow",
            "Documentation": [
              " Value too low"
            ]
          },
          {
            "Name": "ProposalMissing",
            "Documentation": [
              " Proposal does not exist"
            ]
          },
          {
            "Name": "BadIndex",
            "Documentation": [
              " Unknown index"
            ]
          },
          {
            "Name": "AlreadyCanceled",
            "Documentation": [
              " Cannot cancel the same proposal twice"
            ]
          },
          {
            "Name": "DuplicateProposal",
            "Documentation": [
              " Proposal already made"
            ]
          },
          {
            "Name": "ProposalBlacklisted",
            "Documentation": [
              " Proposal still blacklisted"
            ]
          },
          {
            "Name": "NotSimpleMajority",
            "Documentation": [
              " Next external proposal not simple majority"
            ]
          },
          {
            "Name": "InvalidHash",
            "Documentation": [
              " Invalid hash"
            ]
          },
          {
            "Name": "NoProposal",
            "Documentation": [
              " No external proposal"
            ]
          },
          {
            "Name": "AlreadyVetoed",
            "Documentation": [
              " Identity may not veto a proposal twice"
            ]
          },
          {
            "Name": "NotDelegated",
            "Documentation": [
              " Not delegated"
            ]
          },
          {
            "Name": "DuplicatePreimage",
            "Documentation": [
              " Preimage already noted"
            ]
          },
          {
            "Name": "NotImminent",
            "Documentation": [
              " Not imminent"
            ]
          },
          {
            "Name": "TooEarly",
            "Documentation": [
              " Too early"
            ]
          },
          {
            "Name": "Imminent",
            "Documentation": [
              " Imminent"
            ]
          },
          {
            "Name": "PreimageMissing",
            "Documentation": [
              " Preimage not found"
            ]
          },
          {
            "Name": "ReferendumInvalid",
            "Documentation": [
              " Vote given for invalid referendum"
            ]
          },
          {
            "Name": "PreimageInvalid",
            "Documentation": [
              " Invalid preimage"
            ]
          },
          {
            "Name": "NoneWaiting",
            "Documentation": [
              " No proposals waiting"
            ]
          },
          {
            "Name": "NotLocked",
            "Documentation": [
              " The target account does not have a lock."
            ]
          },
          {
            "Name": "NotExpired",
            "Documentation": [
              " The lock on the account to be unlocked has not yet expired."
            ]
          },
          {
            "Name": "NotVoter",
            "Documentation": [
              " The given account did not vote on the referendum."
            ]
          },
          {
            "Name": "NoPermission",
            "Documentation": [
              " The actor has no permission to conduct the action."
            ]
          },
          {
            "Name": "AlreadyDelegating",
            "Documentation": [
              " The account is already delegating."
            ]
          },
          {
            "Name": "InsufficientFunds",
            "Documentation": [
              " Too high a balance was provided that the account cannot afford."
            ]
          },
          {
            "Name": "NotDelegating",
            "Documentation": [
              " The account is not currently delegating."
            ]
          },
          {
            "Name": "VotesExist",
            "Documentation": [
              " The account currently has votes attached to it and the operation cannot succeed until",
              " these are removed, either through `unvote` or `reap_vote`."
            ]
          },
          {
            "Name": "InstantNotAllowed",
            "Documentation": [
              " The instant referendum origin is currently disallowed."
            ]
          },
          {
            "Name": "Nonsense",
            "Documentation": [
              " Delegation to oneself makes no sense."
            ]
          },
          {
            "Name": "WrongUpperBound",
            "Documentation": [
              " Invalid upper bound."
            ]
          },
          {
            "Name": "MaxVotesReached",
            "Documentation": [
              " Maximum number of votes reached."
            ]
          },
          {
            "Name": "InvalidWitness",
            "Documentation": [
              " The provided witness data is wrong."
            ]
          },
          {
            "Name": "TooManyProposals",
            "Documentation": [
              " Maximum number of proposals reached."
            ]
          }
        ],
        "Index": 61
      },
      {
        "Name": "CouncilCollective",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Instance1Collective",
          "Items": [
            {
              "Name": "Proposals",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "BoundedVec\u003cT::Hash, T::MaxProposals\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The hashes of the active proposals."
              ]
            },
            {
              "Name": "ProposalOf",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": true
                  },
                  "Key": "T::Hash",
                  "Value": "\u003cT as Config\u003cI\u003e\u003e::Proposal",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Actual proposal for a given hash, if it's current."
              ]
            },
            {
              "Name": "Voting",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": true
                  },
                  "Key": "T::Hash",
                  "Value": "Votes\u003cT::AccountId, T::BlockNumber\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Votes on a given proposal, if it is ongoing."
              ]
            },
            {
              "Name": "ProposalCount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u32",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Proposals so far."
              ]
            },
            {
              "Name": "Members",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cT::AccountId\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The current members of the collective. This is stored sorted (just by value)."
              ]
            },
            {
              "Name": "Prime",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::AccountId",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The prime member that helps determine the default vote behavior in case of absentations."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "set_members",
            "Args": [
              {
                "Name": "new_members",
                "Type": "Vec\u003cT::AccountId\u003e"
              },
              {
                "Name": "prime",
                "Type": "Option\u003cT::AccountId\u003e"
              },
              {
                "Name": "old_count",
                "Type": "MemberCount"
              }
            ],
            "Documentation": [
              " Set the collective's membership.",
              "",
              " - `new_members`: The new member list. Be nice to the chain and provide it sorted.",
              " - `prime`: The prime member whose vote sets the default.",
              " - `old_count`: The upper bound for the previous number of members in storage.",
              "                Used for weight estimation.",
              "",
              " Requires root origin.",
              "",
              " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
              "       the weight estimations rely on it to estimate dispatchable weight.",
              "",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(MP + N)` where:",
              "   - `M` old-members-count (code- and governance-bounded)",
              "   - `N` new-members-count (code- and governance-bounded)",
              "   - `P` proposals-count (code-bounded)",
              " - DB:",
              "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members",
              "   - 1 storage read (codec `O(P)`) for reading the proposals",
              "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
              "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "execute",
            "Args": [
              {
                "Name": "proposal",
                "Type": "Box\u003c\u003cT as Config\u003cI\u003e\u003e::Proposal\u003e"
              },
              {
                "Name": "length_bound",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Dispatch a proposal from a member using the `Member` origin.",
              "",
              " Origin must be a member of the collective.",
              "",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`",
              " - DB: 1 read (codec `O(M)`) + DB access of `proposal`",
              " - 1 event",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "propose",
            "Args": [
              {
                "Name": "threshold",
                "Type": "Compact\u003cMemberCount\u003e"
              },
              {
                "Name": "proposal",
                "Type": "Box\u003c\u003cT as Config\u003cI\u003e\u003e::Proposal\u003e"
              },
              {
                "Name": "length_bound",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Add a new proposal to either be voted on or executed directly.",
              "",
              " Requires the sender to be member.",
              "",
              " `threshold` determines whether `proposal` is executed directly (`threshold \u003c 2`)",
              " or put up for voting.",
              "",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(B + M + P1)` or `O(B + M + P2)` where:",
              "   - `B` is `proposal` size in bytes (length-fee-bounded)",
              "   - `M` is members-count (code- and governance-bounded)",
              "   - branching is influenced by `threshold` where:",
              "     - `P1` is proposal execution complexity (`threshold \u003c 2`)",
              "     - `P2` is proposals-count (code-bounded) (`threshold \u003e= 2`)",
              " - DB:",
              "   - 1 storage read `is_member` (codec `O(M)`)",
              "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
              "   - DB accesses influenced by `threshold`:",
              "     - EITHER storage accesses done by `proposal` (`threshold \u003c 2`)",
              "     - OR proposal insertion (`threshold \u003c= 2`)",
              "       - 1 storage mutation `Proposals` (codec `O(P2)`)",
              "       - 1 storage mutation `ProposalCount` (codec `O(1)`)",
              "       - 1 storage write `ProposalOf` (codec `O(B)`)",
              "       - 1 storage write `Voting` (codec `O(M)`)",
              "   - 1 event",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "vote",
            "Args": [
              {
                "Name": "proposal",
                "Type": "T::Hash"
              },
              {
                "Name": "index",
                "Type": "Compact\u003cProposalIndex\u003e"
              },
              {
                "Name": "approve",
                "Type": "bool"
              }
            ],
            "Documentation": [
              " Add an aye or nay vote for the sender to the given proposal.",
              "",
              " Requires the sender to be a member.",
              "",
              " Transaction fees will be waived if the member is voting on any particular proposal",
              " for the first time and the call is successful. Subsequent vote changes will charge a fee.",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(M)` where `M` is members-count (code- and governance-bounded)",
              " - DB:",
              "   - 1 storage read `Members` (codec `O(M)`)",
              "   - 1 storage mutation `Voting` (codec `O(M)`)",
              " - 1 event",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "close",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              },
              {
                "Name": "index",
                "Type": "Compact\u003cProposalIndex\u003e"
              },
              {
                "Name": "proposal_weight_bound",
                "Type": "Compact\u003cWeight\u003e"
              },
              {
                "Name": "length_bound",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Close a vote that is either approved, disapproved or whose voting period has ended.",
              "",
              " May be called by any signed account in order to finish voting and close the proposal.",
              "",
              " If called before the end of the voting period it will only close the vote if it is",
              " has enough votes to be approved or disapproved.",
              "",
              " If called after the end of the voting period abstentions are counted as rejections",
              " unless there is a prime member set and the prime member cast an approval.",
              "",
              " If the close operation completes successfully with disapproval, the transaction fee will",
              " be waived. Otherwise execution of the approved operation will be charged to the caller.",
              "",
              " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.",
              " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
              "                   `storage::read` so it is `size_of::\u003cu32\u003e() == 4` larger than the pure length.",
              "",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(B + M + P1 + P2)` where:",
              "   - `B` is `proposal` size in bytes (length-fee-bounded)",
              "   - `M` is members-count (code- and governance-bounded)",
              "   - `P1` is the complexity of `proposal` preimage.",
              "   - `P2` is proposal-count (code-bounded)",
              " - DB:",
              "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
              "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)",
              "  - any mutations done while executing `proposal` (`P1`)",
              " - up to 3 events",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "disapprove_proposal",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              }
            ],
            "Documentation": [
              " Disapprove a proposal, close, and remove it from the system, regardless of its current state.",
              "",
              " Must be called by the Root origin.",
              "",
              " Parameters:",
              " * `proposal_hash`: The hash of the proposal that should be disapproved.",
              "",
              " # \u003cweight\u003e",
              " Complexity: O(P) where P is the number of max proposals",
              " DB Weight:",
              " * Reads: Proposals",
              " * Writes: Voting, Proposals, ProposalOf",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Proposed",
            "Args": [
              "AccountId",
              "ProposalIndex",
              "Hash",
              "MemberCount"
            ],
            "Documentation": [
              " A motion (given hash) has been proposed (by given account) with a threshold (given",
              " `MemberCount`).",
              " \\[account, proposal_index, proposal_hash, threshold\\]"
            ]
          },
          {
            "Name": "Voted",
            "Args": [
              "AccountId",
              "Hash",
              "bool",
              "MemberCount",
              "MemberCount"
            ],
            "Documentation": [
              " A motion (given hash) has been voted on by given account, leaving",
              " a tally (yes votes and no votes given respectively as `MemberCount`).",
              " \\[account, proposal_hash, voted, yes, no\\]"
            ]
          },
          {
            "Name": "Approved",
            "Args": [
              "Hash"
            ],
            "Documentation": [
              " A motion was approved by the required threshold.",
              " \\[proposal_hash\\]"
            ]
          },
          {
            "Name": "Disapproved",
            "Args": [
              "Hash"
            ],
            "Documentation": [
              " A motion was not approved by the required threshold.",
              " \\[proposal_hash\\]"
            ]
          },
          {
            "Name": "Executed",
            "Args": [
              "Hash",
              "DispatchResult"
            ],
            "Documentation": [
              " A motion was executed; result will be `Ok` if it returned without error.",
              " \\[proposal_hash, result\\]"
            ]
          },
          {
            "Name": "MemberExecuted",
            "Args": [
              "Hash",
              "DispatchResult"
            ],
            "Documentation": [
              " A single member did some action; result will be `Ok` if it returned without error.",
              " \\[proposal_hash, result\\]"
            ]
          },
          {
            "Name": "Closed",
            "Args": [
              "Hash",
              "MemberCount",
              "MemberCount"
            ],
            "Documentation": [
              " A proposal was closed because its threshold was reached or after its duration was up.",
              " \\[proposal_hash, yes, no\\]"
            ]
          }
        ],
        "Constants": null,
        "Errors": [
          {
            "Name": "NotMember",
            "Documentation": [
              " Account is not a member"
            ]
          },
          {
            "Name": "DuplicateProposal",
            "Documentation": [
              " Duplicate proposals not allowed"
            ]
          },
          {
            "Name": "ProposalMissing",
            "Documentation": [
              " Proposal must exist"
            ]
          },
          {
            "Name": "WrongIndex",
            "Documentation": [
              " Mismatched index"
            ]
          },
          {
            "Name": "DuplicateVote",
            "Documentation": [
              " Duplicate vote ignored"
            ]
          },
          {
            "Name": "AlreadyInitialized",
            "Documentation": [
              " Members are already initialized!"
            ]
          },
          {
            "Name": "TooEarly",
            "Documentation": [
              " The close call was made too early, before the end of the voting."
            ]
          },
          {
            "Name": "TooManyProposals",
            "Documentation": [
              " There can only be a maximum of `MaxProposals` active proposals."
            ]
          },
          {
            "Name": "WrongProposalWeight",
            "Documentation": [
              " The given weight bound for the proposal was too low."
            ]
          },
          {
            "Name": "WrongProposalLength",
            "Documentation": [
              " The given length bound for the proposal was too low."
            ]
          }
        ],
        "Index": 70
      },
      {
        "Name": "TechComitteeCollective",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Instance2Collective",
          "Items": [
            {
              "Name": "Proposals",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "BoundedVec\u003cT::Hash, T::MaxProposals\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The hashes of the active proposals."
              ]
            },
            {
              "Name": "ProposalOf",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": true
                  },
                  "Key": "T::Hash",
                  "Value": "\u003cT as Config\u003cI\u003e\u003e::Proposal",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Actual proposal for a given hash, if it's current."
              ]
            },
            {
              "Name": "Voting",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": true
                  },
                  "Key": "T::Hash",
                  "Value": "Votes\u003cT::AccountId, T::BlockNumber\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Votes on a given proposal, if it is ongoing."
              ]
            },
            {
              "Name": "ProposalCount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u32",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Proposals so far."
              ]
            },
            {
              "Name": "Members",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "Vec\u003cT::AccountId\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The current members of the collective. This is stored sorted (just by value)."
              ]
            },
            {
              "Name": "Prime",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "T::AccountId",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " The prime member that helps determine the default vote behavior in case of absentations."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "set_members",
            "Args": [
              {
                "Name": "new_members",
                "Type": "Vec\u003cT::AccountId\u003e"
              },
              {
                "Name": "prime",
                "Type": "Option\u003cT::AccountId\u003e"
              },
              {
                "Name": "old_count",
                "Type": "MemberCount"
              }
            ],
            "Documentation": [
              " Set the collective's membership.",
              "",
              " - `new_members`: The new member list. Be nice to the chain and provide it sorted.",
              " - `prime`: The prime member whose vote sets the default.",
              " - `old_count`: The upper bound for the previous number of members in storage.",
              "                Used for weight estimation.",
              "",
              " Requires root origin.",
              "",
              " NOTE: Does not enforce the expected `MaxMembers` limit on the amount of members, but",
              "       the weight estimations rely on it to estimate dispatchable weight.",
              "",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(MP + N)` where:",
              "   - `M` old-members-count (code- and governance-bounded)",
              "   - `N` new-members-count (code- and governance-bounded)",
              "   - `P` proposals-count (code-bounded)",
              " - DB:",
              "   - 1 storage mutation (codec `O(M)` read, `O(N)` write) for reading and writing the members",
              "   - 1 storage read (codec `O(P)`) for reading the proposals",
              "   - `P` storage mutations (codec `O(M)`) for updating the votes for each proposal",
              "   - 1 storage write (codec `O(1)`) for deleting the old `prime` and setting the new one",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "execute",
            "Args": [
              {
                "Name": "proposal",
                "Type": "Box\u003c\u003cT as Config\u003cI\u003e\u003e::Proposal\u003e"
              },
              {
                "Name": "length_bound",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Dispatch a proposal from a member using the `Member` origin.",
              "",
              " Origin must be a member of the collective.",
              "",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(M + P)` where `M` members-count (code-bounded) and `P` complexity of dispatching `proposal`",
              " - DB: 1 read (codec `O(M)`) + DB access of `proposal`",
              " - 1 event",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "propose",
            "Args": [
              {
                "Name": "threshold",
                "Type": "Compact\u003cMemberCount\u003e"
              },
              {
                "Name": "proposal",
                "Type": "Box\u003c\u003cT as Config\u003cI\u003e\u003e::Proposal\u003e"
              },
              {
                "Name": "length_bound",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Add a new proposal to either be voted on or executed directly.",
              "",
              " Requires the sender to be member.",
              "",
              " `threshold` determines whether `proposal` is executed directly (`threshold \u003c 2`)",
              " or put up for voting.",
              "",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(B + M + P1)` or `O(B + M + P2)` where:",
              "   - `B` is `proposal` size in bytes (length-fee-bounded)",
              "   - `M` is members-count (code- and governance-bounded)",
              "   - branching is influenced by `threshold` where:",
              "     - `P1` is proposal execution complexity (`threshold \u003c 2`)",
              "     - `P2` is proposals-count (code-bounded) (`threshold \u003e= 2`)",
              " - DB:",
              "   - 1 storage read `is_member` (codec `O(M)`)",
              "   - 1 storage read `ProposalOf::contains_key` (codec `O(1)`)",
              "   - DB accesses influenced by `threshold`:",
              "     - EITHER storage accesses done by `proposal` (`threshold \u003c 2`)",
              "     - OR proposal insertion (`threshold \u003c= 2`)",
              "       - 1 storage mutation `Proposals` (codec `O(P2)`)",
              "       - 1 storage mutation `ProposalCount` (codec `O(1)`)",
              "       - 1 storage write `ProposalOf` (codec `O(B)`)",
              "       - 1 storage write `Voting` (codec `O(M)`)",
              "   - 1 event",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "vote",
            "Args": [
              {
                "Name": "proposal",
                "Type": "T::Hash"
              },
              {
                "Name": "index",
                "Type": "Compact\u003cProposalIndex\u003e"
              },
              {
                "Name": "approve",
                "Type": "bool"
              }
            ],
            "Documentation": [
              " Add an aye or nay vote for the sender to the given proposal.",
              "",
              " Requires the sender to be a member.",
              "",
              " Transaction fees will be waived if the member is voting on any particular proposal",
              " for the first time and the call is successful. Subsequent vote changes will charge a fee.",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(M)` where `M` is members-count (code- and governance-bounded)",
              " - DB:",
              "   - 1 storage read `Members` (codec `O(M)`)",
              "   - 1 storage mutation `Voting` (codec `O(M)`)",
              " - 1 event",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "close",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              },
              {
                "Name": "index",
                "Type": "Compact\u003cProposalIndex\u003e"
              },
              {
                "Name": "proposal_weight_bound",
                "Type": "Compact\u003cWeight\u003e"
              },
              {
                "Name": "length_bound",
                "Type": "Compact\u003cu32\u003e"
              }
            ],
            "Documentation": [
              " Close a vote that is either approved, disapproved or whose voting period has ended.",
              "",
              " May be called by any signed account in order to finish voting and close the proposal.",
              "",
              " If called before the end of the voting period it will only close the vote if it is",
              " has enough votes to be approved or disapproved.",
              "",
              " If called after the end of the voting period abstentions are counted as rejections",
              " unless there is a prime member set and the prime member cast an approval.",
              "",
              " If the close operation completes successfully with disapproval, the transaction fee will",
              " be waived. Otherwise execution of the approved operation will be charged to the caller.",
              "",
              " + `proposal_weight_bound`: The maximum amount of weight consumed by executing the closed proposal.",
              " + `length_bound`: The upper bound for the length of the proposal in storage. Checked via",
              "                   `storage::read` so it is `size_of::\u003cu32\u003e() == 4` larger than the pure length.",
              "",
              " # \u003cweight\u003e",
              " ## Weight",
              " - `O(B + M + P1 + P2)` where:",
              "   - `B` is `proposal` size in bytes (length-fee-bounded)",
              "   - `M` is members-count (code- and governance-bounded)",
              "   - `P1` is the complexity of `proposal` preimage.",
              "   - `P2` is proposal-count (code-bounded)",
              " - DB:",
              "  - 2 storage reads (`Members`: codec `O(M)`, `Prime`: codec `O(1)`)",
              "  - 3 mutations (`Voting`: codec `O(M)`, `ProposalOf`: codec `O(B)`, `Proposals`: codec `O(P2)`)",
              "  - any mutations done while executing `proposal` (`P1`)",
              " - up to 3 events",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "disapprove_proposal",
            "Args": [
              {
                "Name": "proposal_hash",
                "Type": "T::Hash"
              }
            ],
            "Documentation": [
              " Disapprove a proposal, close, and remove it from the system, regardless of its current state.",
              "",
              " Must be called by the Root origin.",
              "",
              " Parameters:",
              " * `proposal_hash`: The hash of the proposal that should be disapproved.",
              "",
              " # \u003cweight\u003e",
              " Complexity: O(P) where P is the number of max proposals",
              " DB Weight:",
              " * Reads: Proposals",
              " * Writes: Voting, Proposals, ProposalOf",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Proposed",
            "Args": [
              "AccountId",
              "ProposalIndex",
              "Hash",
              "MemberCount"
            ],
            "Documentation": [
              " A motion (given hash) has been proposed (by given account) with a threshold (given",
              " `MemberCount`).",
              " \\[account, proposal_index, proposal_hash, threshold\\]"
            ]
          },
          {
            "Name": "Voted",
            "Args": [
              "AccountId",
              "Hash",
              "bool",
              "MemberCount",
              "MemberCount"
            ],
            "Documentation": [
              " A motion (given hash) has been voted on by given account, leaving",
              " a tally (yes votes and no votes given respectively as `MemberCount`).",
              " \\[account, proposal_hash, voted, yes, no\\]"
            ]
          },
          {
            "Name": "Approved",
            "Args": [
              "Hash"
            ],
            "Documentation": [
              " A motion was approved by the required threshold.",
              " \\[proposal_hash\\]"
            ]
          },
          {
            "Name": "Disapproved",
            "Args": [
              "Hash"
            ],
            "Documentation": [
              " A motion was not approved by the required threshold.",
              " \\[proposal_hash\\]"
            ]
          },
          {
            "Name": "Executed",
            "Args": [
              "Hash",
              "DispatchResult"
            ],
            "Documentation": [
              " A motion was executed; result will be `Ok` if it returned without error.",
              " \\[proposal_hash, result\\]"
            ]
          },
          {
            "Name": "MemberExecuted",
            "Args": [
              "Hash",
              "DispatchResult"
            ],
            "Documentation": [
              " A single member did some action; result will be `Ok` if it returned without error.",
              " \\[proposal_hash, result\\]"
            ]
          },
          {
            "Name": "Closed",
            "Args": [
              "Hash",
              "MemberCount",
              "MemberCount"
            ],
            "Documentation": [
              " A proposal was closed because its threshold was reached or after its duration was up.",
              " \\[proposal_hash, yes, no\\]"
            ]
          }
        ],
        "Constants": null,
        "Errors": [
          {
            "Name": "NotMember",
            "Documentation": [
              " Account is not a member"
            ]
          },
          {
            "Name": "DuplicateProposal",
            "Documentation": [
              " Duplicate proposals not allowed"
            ]
          },
          {
            "Name": "ProposalMissing",
            "Documentation": [
              " Proposal must exist"
            ]
          },
          {
            "Name": "WrongIndex",
            "Documentation": [
              " Mismatched index"
            ]
          },
          {
            "Name": "DuplicateVote",
            "Documentation": [
              " Duplicate vote ignored"
            ]
          },
          {
            "Name": "AlreadyInitialized",
            "Documentation": [
              " Members are already initialized!"
            ]
          },
          {
            "Name": "TooEarly",
            "Documentation": [
              " The close call was made too early, before the end of the voting."
            ]
          },
          {
            "Name": "TooManyProposals",
            "Documentation": [
              " There can only be a maximum of `MaxProposals` active proposals."
            ]
          },
          {
            "Name": "WrongProposalWeight",
            "Documentation": [
              " The given weight bound for the proposal was too low."
            ]
          },
          {
            "Name": "WrongProposalLength",
            "Documentation": [
              " The given length bound for the proposal was too low."
            ]
          }
        ],
        "Index": 71
      },
      {
        "Name": "Treasury",
        "HasStorage": true,
        "Storage": {
          "Prefix": "Treasury",
          "Items": [
            {
              "Name": "ProposalCount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "ProposalIndex",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Number of proposals that have been made."
              ]
            },
            {
              "Name": "Proposals",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": true,
                    "IsIdentity": false
                  },
                  "Key": "ProposalIndex",
                  "Value": "Proposal\u003cT::AccountId, BalanceOf\u003cT, I\u003e\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Proposals that have been made."
              ]
            },
            {
              "Name": "Approvals",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "BoundedVec\u003cProposalIndex, T::MaxApprovals\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": [
                " Proposal indices that have been approved but not yet awarded."
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "propose_spend",
            "Args": [
              {
                "Name": "value",
                "Type": "Compact\u003cBalanceOf\u003cT, I\u003e\u003e"
              },
              {
                "Name": "beneficiary",
                "Type": "\u003cT::Lookup as StaticLookup\u003e::Source"
              }
            ],
            "Documentation": [
              " Put forward a suggestion for spending. A deposit proportional to the value",
              " is reserved and slashed if the proposal is rejected. It is returned once the",
              " proposal is awarded.",
              "",
              " # \u003cweight\u003e",
              " - Complexity: O(1)",
              " - DbReads: `ProposalCount`, `origin account`",
              " - DbWrites: `ProposalCount`, `Proposals`, `origin account`",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "reject_proposal",
            "Args": [
              {
                "Name": "proposal_id",
                "Type": "Compact\u003cProposalIndex\u003e"
              }
            ],
            "Documentation": [
              " Reject a proposed spend. The original deposit will be slashed.",
              "",
              " May only be called from `T::RejectOrigin`.",
              "",
              " # \u003cweight\u003e",
              " - Complexity: O(1)",
              " - DbReads: `Proposals`, `rejected proposer account`",
              " - DbWrites: `Proposals`, `rejected proposer account`",
              " # \u003c/weight\u003e"
            ]
          },
          {
            "Name": "approve_proposal",
            "Args": [
              {
                "Name": "proposal_id",
                "Type": "Compact\u003cProposalIndex\u003e"
              }
            ],
            "Documentation": [
              " Approve a proposal. At a later time, the proposal will be allocated to the beneficiary",
              " and the original deposit will be returned.",
              "",
              " May only be called from `T::ApproveOrigin`.",
              "",
              " # \u003cweight\u003e",
              " - Complexity: O(1).",
              " - DbReads: `Proposals`, `Approvals`",
              " - DbWrite: `Approvals`",
              " # \u003c/weight\u003e"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "Proposed",
            "Args": [
              "ProposalIndex"
            ],
            "Documentation": [
              " New proposal. \\[proposal_index\\]"
            ]
          },
          {
            "Name": "Spending",
            "Args": [
              "Balance"
            ],
            "Documentation": [
              " We have ended a spend period and will now allocate funds. \\[budget_remaining\\]"
            ]
          },
          {
            "Name": "Awarded",
            "Args": [
              "ProposalIndex",
              "Balance",
              "AccountId"
            ],
            "Documentation": [
              " Some funds have been allocated. \\[proposal_index, award, beneficiary\\]"
            ]
          },
          {
            "Name": "Rejected",
            "Args": [
              "ProposalIndex",
              "Balance"
            ],
            "Documentation": [
              " A proposal was rejected; funds were slashed. \\[proposal_index, slashed\\]"
            ]
          },
          {
            "Name": "Burnt",
            "Args": [
              "Balance"
            ],
            "Documentation": [
              " Some of our funds have been burnt. \\[burn\\]"
            ]
          },
          {
            "Name": "Rollover",
            "Args": [
              "Balance"
            ],
            "Documentation": [
              " Spending has finished; this is the amount that rolls over until next spend.",
              " \\[budget_remaining\\]"
            ]
          },
          {
            "Name": "Deposit",
            "Args": [
              "Balance"
            ],
            "Documentation": [
              " Some funds have been deposited. \\[deposit\\]"
            ]
          }
        ],
        "Constants": [
          {
            "Name": "ProposalBond",
            "Type": "Permill",
            "Value": "UMMAAA==",
            "Documentation": [
              " Fraction of a proposal's value that should be bonded in order to place the proposal.",
              " An accepted proposal gets these back. A rejected proposal does not."
            ]
          },
          {
            "Name": "ProposalBondMinimum",
            "Type": "BalanceOf\u003cT, I\u003e",
            "Value": "AABkp7O24A0AAAAAAAAAAA==",
            "Documentation": [
              " Minimum amount of funds that should be placed in a deposit for making a proposal."
            ]
          },
          {
            "Name": "SpendPeriod",
            "Type": "T::BlockNumber",
            "Value": "wKgAAA==",
            "Documentation": [
              " Period between successive spends."
            ]
          },
          {
            "Name": "Burn",
            "Type": "Permill",
            "Value": "AAAAAA==",
            "Documentation": [
              " Percentage of spare funds (if any) that are burnt per spend period."
            ]
          },
          {
            "Name": "PalletId",
            "Type": "PalletId",
            "Value": "cHkvdHJzcnk=",
            "Documentation": [
              " The treasury's module id, used for deriving its sovereign account ID."
            ]
          }
        ],
        "Errors": [
          {
            "Name": "InsufficientProposersBalance",
            "Documentation": [
              " Proposer's balance is too low."
            ]
          },
          {
            "Name": "InvalidIndex",
            "Documentation": [
              " No proposal or bounty at that index."
            ]
          },
          {
            "Name": "TooManyApprovals",
            "Documentation": [
              " Too many approvals in the queue."
            ]
          }
        ],
        "Index": 80
      },
      {
        "Name": "CrowdloanRewards",
        "HasStorage": true,
        "Storage": {
          "Prefix": "CrowdloanRewards",
          "Items": [
            {
              "Name": "AccountsPayable",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "\u003cT as frame_system::Config\u003e::AccountId",
                  "Value": "RewardInfo\u003cT\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": null
            },
            {
              "Name": "ClaimedRelayChainIds",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "T::RelayChainAccountId",
                  "Value": "()",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": null
            },
            {
              "Name": "UnassociatedContributions",
              "Modifier": {
                "IsOptional": true,
                "IsDefault": false,
                "IsRequired": false
              },
              "Type": {
                "IsType": false,
                "AsType": "",
                "IsMap": true,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": true,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "T::RelayChainAccountId",
                  "Value": "RewardInfo\u003cT\u003e",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": null
            },
            {
              "Name": "Initialized",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "bool",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AA==",
              "Documentation": null
            },
            {
              "Name": "InitRelayBlock",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "relay_chain::BlockNumber",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Relay block height at the initialization of the pallet"
              ]
            },
            {
              "Name": "InitializedRewardAmount",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "BalanceOf\u003cT\u003e",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAAAAAAAAAAAAAAAAAA==",
              "Documentation": [
                " Total initialized amount so far. We store this to make pallet funds == contributors reward",
                " check easier and more efficient"
              ]
            },
            {
              "Name": "TotalContributors",
              "Modifier": {
                "IsOptional": false,
                "IsDefault": true,
                "IsRequired": false
              },
              "Type": {
                "IsType": true,
                "AsType": "u32",
                "IsMap": false,
                "AsMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key": "",
                  "Value": "",
                  "Linked": false
                },
                "IsDoubleMap": false,
                "AsDoubleMap": {
                  "Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  },
                  "Key1": "",
                  "Key2": "",
                  "Value": "",
                  "Key2Hasher": {
                    "IsBlake2_128": false,
                    "IsBlake2_256": false,
                    "IsBlake2_128Concat": false,
                    "IsTwox128": false,
                    "IsTwox256": false,
                    "IsTwox64Concat": false,
                    "IsIdentity": false
                  }
                },
                "IsNMap": false,
                "AsNMap": {
                  "Keys": null,
                  "Hashers": null,
                  "Value": ""
                }
              },
              "Fallback": "AAAAAA==",
              "Documentation": [
                " Total number of contributors to aid hinting benchmarking"
              ]
            }
          ]
        },
        "HasCalls": true,
        "Calls": [
          {
            "Name": "associate_native_identity",
            "Args": [
              {
                "Name": "reward_account",
                "Type": "\u003cT as frame_system::Config\u003e::AccountId"
              },
              {
                "Name": "relay_account",
                "Type": "T::RelayChainAccountId"
              },
              {
                "Name": "proof",
                "Type": "MultiSignature"
              }
            ],
            "Documentation": [
              " Associate a native rewards_destination identity with a crowdloan contribution.",
              "",
              " This is an unsigned call because the caller may not have any funds to pay fees with.",
              " This is inspired by Polkadot's claims pallet:",
              " https://github.com/paritytech/polkadot/blob/master/runtime/common/src/claims.rs",
              "",
              " The contributor needs to issue an additional addmemo transaction if it wants to receive",
              " the reward in a parachain native account. For the moment I will leave this function here",
              " just in case the contributor forgot to add such a memo field. Whenever we can read the",
              " state of the relay chain, we should first check whether that memo field exists in the",
              " contribution"
            ]
          },
          {
            "Name": "claim",
            "Args": null,
            "Documentation": [
              " Collect whatever portion of your reward are currently vested. The first time each",
              " contributor calls this function pays no fees"
            ]
          },
          {
            "Name": "update_reward_address",
            "Args": [
              {
                "Name": "new_reward_account",
                "Type": "\u003cT as frame_system::Config\u003e::AccountId"
              }
            ],
            "Documentation": [
              " Update reward address. To determine whether its something we want to keep"
            ]
          },
          {
            "Name": "initialize_reward_vec",
            "Args": [
              {
                "Name": "rewards",
                "Type": "Vec\u003c\n(T::RelayChainAccountId, Option\u003c\u003cT as frame_system::Config\u003e::\n AccountId\u003e, BalanceOf\u003cT\u003e)\u003e"
              },
              {
                "Name": "index",
                "Type": "u32"
              },
              {
                "Name": "limit",
                "Type": "u32"
              }
            ],
            "Documentation": [
              " Initialize the reward distribution storage. It shortcuts whenever an error is found",
              " We can change this behavior to check this beforehand if we prefer",
              " We only set this to \"initialized\" once we receive index==limit",
              " This is expected to be executed with batch_all, that atomically initializes contributions",
              " TODO Should we perform sanity checks here? (i.e., min contribution)"
            ]
          }
        ],
        "HasEvents": true,
        "Events": [
          {
            "Name": "InitialPaymentMade",
            "Args": [
              "\u003cT as frame_system::Config\u003e::AccountId",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " The initial payment of InitializationPayment % was paid"
            ]
          },
          {
            "Name": "NativeIdentityAssociated",
            "Args": [
              "T::RelayChainAccountId",
              "\u003cT as frame_system::Config\u003e::AccountId",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " Someone has proven they made a contribution and associated a native identity with it.",
              " Data is the relay account,  native account and the total amount of _rewards_ that will be paid"
            ]
          },
          {
            "Name": "RewardsPaid",
            "Args": [
              "\u003cT as frame_system::Config\u003e::AccountId",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " A contributor has claimed some rewards.",
              " Data is the account getting paid and the amount of rewards paid."
            ]
          },
          {
            "Name": "RewardAddressUpdated",
            "Args": [
              "\u003cT as frame_system::Config\u003e::AccountId",
              "\u003cT as frame_system::Config\u003e::AccountId"
            ],
            "Documentation": [
              " A contributor has updated the reward address."
            ]
          },
          {
            "Name": "InitializedAlreadyInitializedAccount",
            "Args": [
              "T::RelayChainAccountId",
              "Option\u003c\u003cT as frame_system::Config\u003e::AccountId\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " When initializing the reward vec an already initialized account was found"
            ]
          },
          {
            "Name": "InitializedAccountWithNotEnoughContribution",
            "Args": [
              "T::RelayChainAccountId",
              "Option\u003c\u003cT as frame_system::Config\u003e::AccountId\u003e",
              "BalanceOf\u003cT\u003e"
            ],
            "Documentation": [
              " When initializing the reward vec an already initialized account was found"
            ]
          }
        ],
        "Constants": [
          {
            "Name": "InitializationPayment",
            "Type": "Perbill",
            "Value": "AKPhEQ==",
            "Documentation": [
              " Percentage to be payed at initialization"
            ]
          },
          {
            "Name": "VestingPeriod",
            "Type": "relay_chain::BlockNumber",
            "Value": "AOokAA==",
            "Documentation": [
              " The total vesting period. Ideally this should be less or equal",
              " than the lease period to ensure contributors vest the tokens during the lease"
            ]
          }
        ],
        "Errors": [
          {
            "Name": "AlreadyAssociated",
            "Documentation": [
              " User trying to associate a native identity with a relay chain identity for posterior",
              " reward claiming provided an already associated relay chain identity"
            ]
          },
          {
            "Name": "BatchBeyondFundPot",
            "Documentation": [
              " Trying to introduce a batch that goes beyond the limits of the funds"
            ]
          },
          {
            "Name": "FirstClaimAlreadyDone",
            "Documentation": [
              " First claim already done"
            ]
          },
          {
            "Name": "RewardNotHighEnough",
            "Documentation": [
              " The contribution is not high enough to be eligible for rewards"
            ]
          },
          {
            "Name": "InvalidClaimSignature",
            "Documentation": [
              " User trying to associate a native identity with a relay chain identity for posterior",
              " reward claiming provided a wrong signature"
            ]
          },
          {
            "Name": "InvalidFreeClaimSignature",
            "Documentation": [
              " User trying to claim the first free reward provided the wrong signature"
            ]
          },
          {
            "Name": "NoAssociatedClaim",
            "Documentation": [
              " User trying to claim an award did not have an claim associated with it. This may mean",
              " they did not contribute to the crowdloan, or they have not yet associated a native id",
              " with their contribution"
            ]
          },
          {
            "Name": "RewardsAlreadyClaimed",
            "Documentation": [
              " User trying to claim rewards has already claimed all rewards associated with its",
              " identity and contribution"
            ]
          },
          {
            "Name": "RewardVecAlreadyInitialized",
            "Documentation": [
              " Reward vec has already been initialized"
            ]
          },
          {
            "Name": "RewardVecNotFullyInitializedYet",
            "Documentation": [
              " Reward vec has not yet been fully initialized"
            ]
          },
          {
            "Name": "RewardsDoNotMatchFund",
            "Documentation": [
              " Reward vec has already been initialized"
            ]
          }
        ],
        "Index": 90
      }
    ],
    "Extrinsic": {
      "Version": 4,
      "SignedExtensions": [
        "CheckSpecVersion",
        "CheckTxVersion",
        "CheckGenesis",
        "CheckMortality",
        "CheckNonce",
        "CheckWeight",
        "ChargeTransactionPayment"
      ]
    }
  }
}